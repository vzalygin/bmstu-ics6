#import "../version.typ": *

= Аналитический обзор существующих решений

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько наиболее значимых языков, каждый из которых привнес важные нововведения в группу языков.

== ЯП Forth
/* идея, синтаксис, доступные команды, типизация, область применения и различные особенности тд */

Forth представляет собой стековый конкатенативный язык программирования, созданный Чарльзом Муром в начале 1970-х годов как сочетание расширяемого языка и интерактивной методологии разработки. Основная идея состоит в минимальном ядре и словаре «слов» (подпрограмм), через которые реализуется как высокоуровневая логика, так и низкоуровневое аппаратное управление; новые слова добавляются прямо во время работы системы, что позволяет подстраивать язык под конкретную предметную область. Синтаксис несложен: используется обратная польская нотация, программа -- это последовательность слов, разделённых пробелами; интерпретатор читает токены, ищет их в словаре и либо выполняет связанный код, либо интерпретирует токен как число и кладёт его на стек.

С точки зрения семантики типов Forth рассматривается как «безтиповый»: данные представляются машинными словами фиксированной разрядности, а язык не навязывает проверку согласованности типов -- ответственность за корректность интерпретации содержимого стека возлагается на разработчика. Такой подход обеспечивает максимальную гибкость и предсказуемое временное поведение, но затрудняет статический анализ и контроль. Forth применяется в встроенных и ресурсно-ограниченных системах, прошивках, системах реального времени и космической технике: он используется в контроллерах космических аппаратов и приборов NASA, а также в реализациях Open Firmware (стандарт, регламентирующий принцип описания аппаратной конфигурации устройств) для платформ Apple, IBM и Sun. К языка особенностям относятся малый размер полной среды (компилятор, интерпретатор и редактор умещаются в память 8-битных систем), компиляция в нитевой код (представление программы, полностью состоящее из последовательности вызовов подпрограмм) для ускоренной интерпретации, а также единство языка и среды: Forth одновременно служит командной оболочкой, компилятором и минимальной операционной системой, а его стандарт (ANS Forth) описывает лишь набор слов и модель стека, оставляя пользователю свободу строить поверх ядра собственные DSL и диалекты.

Стандартной библиотеки у языка в привычном понимании нет -- расширение возможностей происходит за счет включения в среду дополнительных наборов слов.

Определения новых слов задаются конструкцией вида ": NAME ... ;", причём большинство лексем -- от переменных до управляющих конструкций -- являются словами. Стандартный «core word set» ANS Forth включает базовые стековые операции ("DUP", "DROP", "SWAP", "OVER"), арифметику ("+ - \* /"), сравнения, примитивы работы с памятью ("\@" -- чтение по адресу, "!" -- запись по адресу), конструкции ветвления и циклов ("IF … ELSE … THEN", "DO … LOOP"), а также определяющие слова "CREATE", "VARIABLE", "CONSTANT" и др.; остальные word set’ы стандарта являются опциональными расширениями. Почти все управляющие слова в Forth реализуются при помощи понятия слов времени компиляции -- это конструкции, которые во время компиляции компилятор разворачивает в другие слова. Например, конструкция с ветвлением "... DUP 6 < IF DROP 5 ELSE 1 - THEN ..." разворачивается в последовательность слов "... DUP LIT 6 < ?BRANCH 5 DROP LIT 5 BRANCH 3 LIT 1 - ..." -- конструкция условного перехода заменена на слова условного и безусловного переходов.

Поскольку Forth является интерактивной средой, процесс исполнения программы можно разделить на 2 составляющие: состояние интерпретации и состояние компиляции. В состоянии интерпретации среда занимается исполнением примитивных слов. В то же время, если среда в процессе встречает некоторый набор слов (например, ":" -- создание нового слова), то она переходит в состояние компиляции и осуществляет разбор подпрограмм, встречаемых синтаксических конструкций. Выполнить переключение состояния также можно при помощи специальных слов "[" -- переход в состояние интерпретации и "]" -- переход в состояние компиляции. 

В листинге @forth-example "HELLO", которое затем вызывается для вывода в консоль. Круглые кавычки используются для комментариев.

#листинг(```
: HELLO  CR ." Hello, World!" ;
HELLO ( выводит Hello, World! в консоль на следующей строке после вызова слова )
```)[ Определение и использование слова "HELLO" ] <forth-example>

В итоге язык Forth дает ряд возможностей при программировании систем с ограниченными ресурсами. Множество низкоуровневых слов, ряд оптимизаций, точность и гибкость исполнения позволяют писать маленькие и быстрые программы. 

== ЯП Joy

В 2001 году Манфред фон Тун в La Trobe University представил язык Joy, как попытку формализации логики стековых языков. Joy -- функциональный стековый конкатенативный язык программирования. 

В отличие от обычных функциональных языков, которые строятся вокруг операции применения функции к аргументу, Joy использует операцию композиции функций. Каждая программа в Joy обозначает унарную функцию вида "Stack → Stack": на вход подаётся состояние (стек данных), в процессе применения команды происходит некая модификация стека и его передача следующей команде, значения и подпрограммы в свою очередь передаются через стек.

С математической точки зрения это формализуется следующим образом: множество всех программ образует синтаксический моноид по операции конкатенации (ассоциативная операция «склейки» программ и пустая программа как нейтральный элемент), а множество функций "Stack -> Stack" — семантический моноид по операции композиции и тождественной функции в роли нейтрального элемента. Отображение, которое каждой программе сопоставляет её «смысл» (как некоторую функцию над стеком), является гомоморфизмом моноидов, то есть сохраняет операцию: смысл "P Q" равен композиции смыслов "P" и "Q", а смысл пустой программы — тождественная функция. /* (Моноид здесь понимается в стандартном алгебраическом смысле: набор объектов + одна ассоциативная операция + нейтральный элемент; гомоморфизм — отображение, которое не ломает эту структуру.)*/

Синтаксис Joy минималистичен и основан на постфиксной записи. Программа — это последовательность слов, разделённых пробелами, исполнение идёт слева направо. Каждое слово выполняет некоторое преобразование над стеком данных. Операторы (арифметические, логические и другие) снимают одно или несколько значений с вершины стека и помещают результат обратно. Для структур данных используются литералы: списки и цитаты программ записываются в квадратных скобках "[...]", множества — в фигурных, строки — в кавычках. Цитата — это значение, содержащее в себе фрагмент программы как данные, который можно затем анализировать или исполнить. Определения новых слов записываются как равенства: "square == dup \* ." определяет слово "square", которое дублирует вершину стека ("dup") и перемножает два верхних элемента ("\*"). Joy при этом остаётся функционально чистым: стандартные операции не изменяют скрытое глобальное состояние, а только преобразуют стек, так что одну и ту же программу можно рассматривать как математическую функцию "Stack → Stack" без побочных эффектов.

При построении идиоматических программ на Joy активно используются комбинаторы. В контексте языка это стековые функции, которые принимают одну или несколько цитат программ (списков слов) и управляют их исполнением различными способами. Например, функция-комбинатор "i" ("interpret") берет вершину стека и исполняет список слов, которые лежали внутри вершины. С точки зрения синтаксиса это эквивалентно опусканию скобочек: "[ 1 print ] i" значит то же самое, что и "1 print". Для ветвлений используется комбинатор "ifte", для циклических алгоритмов -- комбинаторы различных схем рекурсии "primrec", "linrec", "binrec". Программист волен создавать и свои функции-комбинаторы на основе уже существующих через механизм определения новых слов. 

Joy является динамически типизированным языком. В язык встроены числовые (целые и вещественные числа) и агрегатные типы (строки, списки и неупорядоченные множества). Типизация стека на этапе компиляции программы никак не контролируется и проверка типов происходит по факту в момент применения той или иной функции. В случае несовпадения ожидаемого и фактического типов выдается ошибка времени выполнения (в отличие от поведения программ на Forth, где произойдет недопустимая реинтерпертация данных и вследствие нее уход неопределенной поведение). Для борьбы с ошибками несовпадения типов рекомендуется к каждому определению в языке приписывать комментарий в следующей нотации: пишется название функции, затем после двоеточия ее эффект на стек -- какой стек функция принимает и какой стек отдает. Например, нотация функции "dup : A -> A A" и функции "+ : Int Int -> Int". Нотация помогает рассмотреть программу как формулу в рамках алгебры стеков (то есть алгебры, которая строится над вычислениями со стеками в качестве переменных). Такая формализация помогает применять к программам на Joy многие методы теории вычислимости, что является предтечей статического анализа программ.    

Благодаря возможности определять новые слова, которые могут быть комбинаторами или другими функциями, Joy имеет богатую стандартную библиотеку. В стандартной поставке есть несколько библиотек, разбитых по областям применения -- например, "agglib" и "seqlib" содержат обобщенные операции над агрегатами (в контексте языка -- неупорядоченные множества, строки и списки) и последовательностями, "numlib" -- числовые функции и численные методы, "mtrlib" -- функции для работы с матрицами. 

Язык Joy имеет в основном академическое и эксперементальное применением, так как служит для демонстрации применения идей функционального программирования к стековой модели исполнения. Базовая реализация -- интерпретатор на C с автоматической сборкой мусора и набором библиотек. В итоге Joy можно рассматривать как компактную и хорошо формализованную модель стекового языка высокого уровня, где математические понятия моноида и гомоморфизма используются не как абстрактные термины, а как точное описание связи между текстом программы и её поведением при выполнении.

== ЯП Cat и Kitten

== ЯП Factor

== ЯП Wasm

== ЯП Java bytecode

== Выводы


