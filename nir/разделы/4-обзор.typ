#import "../version.typ": *

= Аналитический обзор существующих решений

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько наиболее значимых языков, каждый из которых привнес важные нововведения в группу языков.

== ЯП Forth
/* идея, синтаксис, доступные команды, типизация, область применения и различные особенности тд */

Forth представляет собой стековый конкатенативный язык программирования, созданный Чарльзом Муром в начале 1970-х годов как сочетание расширяемого языка и интерактивной методологии разработки. Основная идея состоит в минимальном ядре и словаре «слов» (подпрограмм), через которые реализуется как высокоуровневая логика, так и низкоуровневое аппаратное управление; новые слова добавляются прямо во время работы системы, что позволяет подстраивать язык под конкретную предметную область. Синтаксис несложен: используется обратная польская нотация, программа -- это последовательность слов, разделённых пробелами; интерпретатор читает токены, ищет их в словаре и либо выполняет связанный код, либо интерпретирует токен как число и кладёт его на стек.

С точки зрения семантики типов Forth рассматривается как «безтиповый»: данные представляются машинными словами фиксированной разрядности, а язык не навязывает проверку согласованности типов -- ответственность за корректность интерпретации содержимого стека возлагается на разработчика. Такой подход обеспечивает максимальную гибкость и предсказуемое временное поведение, но затрудняет статический анализ и контроль. Forth применяется в встроенных и ресурсно-ограниченных системах, прошивках, системах реального времени и космической технике: он используется в контроллерах космических аппаратов и приборов NASA, а также в реализациях Open Firmware (стандарт, регламентирующий принцип описания аппаратной конфигурации устройств) для платформ Apple, IBM и Sun. К языка особенностям относятся малый размер полной среды (компилятор, интерпретатор и редактор умещаются в память 8-битных систем), компиляция в нитевой код (представление программы, полностью состоящее из последовательности вызовов подпрограмм) для ускоренной интерпретации, а также единство языка и среды: Forth одновременно служит командной оболочкой, компилятором и минимальной операционной системой, а его стандарт (ANS Forth) описывает лишь набор слов и модель стека, оставляя пользователю свободу строить поверх ядра собственные DSL и диалекты.

Стандартной библиотеки у языка в привычном понимании нет -- расширение возможностей происходит за счет включения в среду дополнительных наборов слов.

Определения новых слов задаются конструкцией вида ": NAME ... ;", причём большинство лексем -- от переменных до управляющих конструкций -- являются словами. Стандартный «core word set» ANS Forth включает базовые стековые операции ("DUP", "DROP", "SWAP", "OVER"), арифметику ("+ - \* /"), сравнения, примитивы работы с памятью ("\@" -- чтение по адресу, "!" -- запись по адресу), конструкции ветвления и циклов ("IF … ELSE … THEN", "DO … LOOP"), а также определяющие слова "CREATE", "VARIABLE", "CONSTANT" и др.; остальные word set’ы стандарта являются опциональными расширениями. Почти все управляющие слова в Forth реализуются при помощи понятия слов времени компиляции -- это конструкции, которые во время компиляции компилятор разворачивает в другие слова. Например, конструкция с ветвлением "... DUP 6 < IF DROP 5 ELSE 1 - THEN ..." разворачивается в последовательность слов "... DUP LIT 6 < ?BRANCH 5 DROP LIT 5 BRANCH 3 LIT 1 - ..." -- конструкция условного перехода заменена на слова условного и безусловного переходов.

Поскольку Forth является интерактивной средой, процесс исполнения программы можно разделить на 2 составляющие: состояние интерпретации и состояние компиляции. В состоянии интерпретации среда занимается исполнением примитивных слов. В то же время, если среда в процессе встречает некоторый набор слов (например, ":" -- создание нового слова), то она переходит в состояние компиляции и осуществляет разбор подпрограмм, встречаемых синтаксических конструкций. Выполнить переключение состояния также можно при помощи специальных слов "[" -- переход в состояние интерпретации и "]" -- переход в состояние компиляции. 

В листинге @forth-example определяется слово "HELLO", которое затем вызывается и выводит в консоль текст. Круглые кавычки используются для комментариев.

#листинг(```
: HELLO  CR ." Hello, World!" ;
HELLO ( выводит Hello, World! в консоль на следующей строке после вызова слова )
```)[ Определение и использование слова "HELLO" ] <forth-example>

В итоге язык Forth дает ряд возможностей при программировании систем с ограниченными ресурсами. Множество низкоуровневых слов, ряд оптимизаций, точность и гибкость исполнения позволяют писать маленькие и быстрые программы.

== ЯП Joy

В 2001 году Манфред фон Тун в La Trobe University представил язык Joy, как попытку формализации логики стековых языков. Joy -- функциональный стековый конкатенативный язык программирования. 

В отличие от обычных функциональных языков, которые строятся вокруг операции применения функции к аргументу, Joy использует операцию композиции функций. Каждая программа в Joy обозначает унарную функцию вида "stack -> stack": на вход подаётся состояние (стек данных), в процессе применения команды происходит некая модификация стека и его передача следующей команде, значения и подпрограммы в свою очередь передаются через стек.

С математической точки зрения это формализуется следующим образом: множество всех программ образует синтаксический моноид по операции конкатенации (ассоциативная операция «склейки» программ и пустая программа как нейтральный элемент), а множество функций "stack -> stack" — семантический моноид по операции композиции и тождественной функции в роли нейтрального элемента. Отображение, которое каждой программе сопоставляет её «смысл» (как некоторую функцию над стеком), является гомоморфизмом моноидов, то есть сохраняет операцию: смысл "P Q" равен композиции смыслов "P" и "Q", а смысл пустой программы — тождественная функция. /* (Моноид здесь понимается в стандартном алгебраическом смысле: набор объектов + одна ассоциативная операция + нейтральный элемент; гомоморфизм — отображение, которое не ломает эту структуру.)*/

Синтаксис Joy минималистичен и основан на постфиксной записи. Программа — это последовательность слов, разделённых пробелами, исполнение идёт слева направо. Каждое слово выполняет некоторое преобразование над стеком данных. Операторы (арифметические, логические и другие) снимают одно или несколько значений с вершины стека и помещают результат обратно. Для структур данных используются литералы: списки и цитаты программ записываются в квадратных скобках "[...]", множества — в фигурных, строки — в кавычках. Цитата — это значение, содержащее в себе фрагмент программы как данные, который можно затем анализировать или исполнить. Определения новых слов записываются как равенства: "square == dup \* ." определяет слово "square", которое дублирует вершину стека ("dup") и перемножает два верхних элемента ("\*"). Joy при этом остаётся функционально чистым: стандартные операции не изменяют скрытое глобальное состояние, а только преобразуют стек, так что одну и ту же программу можно рассматривать как математическую функцию "stack -> stack" без побочных эффектов.

При построении идиоматических программ на Joy активно используются комбинаторы. В контексте языка это стековые функции, которые принимают одну или несколько цитат программ (списков слов) и управляют их исполнением различными способами. Например, функция-комбинатор "i" ("interpret") берет вершину стека и исполняет список слов, которые лежали внутри вершины. С точки зрения синтаксиса это эквивалентно опусканию скобочек: "[ 1 print ] i" значит то же самое, что и "1 print". Для ветвлений используется комбинатор "ifte", для циклических алгоритмов -- комбинаторы различных схем рекурсии "primrec", "linrec", "binrec". Программист волен создавать и свои функции-комбинаторы на основе уже существующих через механизм определения новых слов. 

Joy является динамически типизированным языком. В язык встроены числовые (целые и вещественные числа), агрегатные типы (строки, списки и неупорядоченные множества) и тип цитат. Типизация стека на этапе компиляции программы никак не контролируется и проверка типов происходит по факту в момент применения той или иной функции. В случае несовпадения ожидаемого и фактического типов выдается ошибка времени выполнения (в отличие от поведения программ на Forth, где произойдет недопустимая реинтерпертация данных и вследствие нее уход неопределенной поведение). Для борьбы с ошибками несовпадения типов рекомендуется к каждому определению в языке приписывать комментарий в следующей нотации: пишется название функции, затем после двоеточия ее эффект на стек -- какой стек функция принимает и какой стек отдает. Например, нотация функции "dup : A -> A A" и функции "+ : Int Int -> Int". Нотация помогает рассмотреть программу как формулу в рамках алгебры стеков (то есть алгебры, которая строится над вычислениями со стеками в качестве переменных). Такая формализация помогает применять к программам на Joy многие методы теории вычислимости, что является предтечей статического анализа программ.    

Благодаря возможности определять новые слова, которые могут быть комбинаторами или другими функциями, Joy имеет богатую стандартную библиотеку. В стандартной поставке есть несколько библиотек, разбитых по областям применения -- например, "agglib" и "seqlib" содержат обобщенные операции над агрегатами (в контексте языка -- неупорядоченные множества, строки и списки) и последовательностями, "numlib" -- числовые функции и численные методы, "mtrlib" -- функции для работы с матрицами. 

Язык Joy имеет в основном академическое и эксперементальное применением, так как служит для демонстрации применения идей функционального программирования к стековой модели исполнения. Базовая реализация -- интерпретатор на C с автоматической сборкой мусора и набором библиотек. В итоге Joy можно рассматривать как компактную и хорошо формализованную модель стекового языка высокого уровня, где математические понятия моноида и гомоморфизма используются не как абстрактные термины, а как точное описание связи между текстом программы и её поведением при выполнении.

// == ЯП Java Bytecode и .NET CIL

== ЯП Cat

Логическим продолжением ЯП Joy является язык Cat, который с 2006 года разрабатывается Кристофером Диггинсом. Автор характеризует свой язык как "Joy с типами". Язык используется для верификации и оптимизации программ под платформу .NET CIL. Язык наследует идею Joy: любая программа рассматривается как функция вида "stack -> stack", а основная операция ― композиция таких функций, реализуемая простой конкатенацией лексем в исходном тексте программы. Cat вводит статическую систему типов поверх этой модели. Это означает, что в момент компиляции компилятор может вычислить размер стека программы и верифицировать программу на соответствие ожидаемым типам на стеке и фактическим. Таким образом при помощи статического анализа возможно предовратить фатальные ошибки времени выполнения, связанные с несовпадением типов, опустошением или переполнением стека. Также статический анализ открывает дороги агрессивным оптимизациями, которые могут менять тексты программ и промежуточных представлен для повышения производительности.

Аналогично Joy, программы на языке Cat опираются на обратную польскую запись с последовательным перечислением слов программы слева направо. Работа с поток исполнения устроена при помощи комбинаторов "if" и "while", соответствующих ветвлению и циклу по условию: комбинаторы принимают набор цитат (которые аналогично Joy записываются в квадратных скобках; еще цитаты называют замыканиями) и огранизуют поток управления должным образом. Определение новых слов возможно при помощи слова "define" -- определение слов глобально и единственно (множественные определения запрещены).

В множестве команд языка доступны арифметические, логические операции, операции сравнения, операции манипуляции стеком и наконец комбинаторы (или же, как привычнее для Cat, -- функции высшего порядка). Также существуют примиты работы с последовательностями, рекурсивными алгоритмами.

Наибольшего внимания заслуживает система типов Cat, благодаря которой язык обзавелся статическим анализом. Система типов Cat описывает поведение функций в терминах потребления и производства элементов стека. Тип функции определяется тем, что функция ожидает на стеке перед началом выполнения, и тем, что она оставляется на стеке после выполнения. Тип записывается как стрелка между конфигурациями стека, например "(int int -> int)" для операции сложения или "('a 'S -> 'a 'a 'S)" для дублирования вершины стека. Слева указываются типы, которые должны находиться на вершине входного стека, справа ― типы элементов на вершине выходного стека. Типы с апострофом ('a, 'b) обозначают типовые переменные (для которых точный тип не важен), а специальные "типовые векторы", обозначаемые заглавными буквами ('A, 'B), представляют произвольные последовательности типов, то есть "хвост" стека. Такое представление соответствует row-полиморфизму: каждая функция не только определяет, какие значения она снимает и кладёт на вершину стека, но и неявно пропускает через себя остальную часть стека, обозначаемую переменной "ряда" типа; это позволяет типизировать локальные преобразования независимо от длины и состава "фона" стека. Статья о типизации функциональных стековых языков формализует эту систему через различие между "родами" (kinds) для обычных типов и для стеков значений: типы значений и типы стеков образуют две категории, между которыми определяются функции "stack -> stack", а типизация выражается в виде правил натурального вывода (правила, которые задают соответствие между набором посылок -- входной конфигурацей стека и выводом из этого -- выходной конфигурацией стека; для каждого слова определен свой набор таких правил) и полиморфной системы родов, позволяющей описывать как отдельные значения, так и целые стековые конфигурации. Вывод типов на основе правил в Cat базируется на вариации алгоритма Хиндли–Милнера, обобщённой на стековые типы и row-полиморфизм, причём языковые конструкции допускают полиморфизм более высоких рангов (то есть возможен логический вывод даже для программ, где используются функции высшего порядка), а аннотации типов (так называемые "stack diagrams") используются как документация и как данные для статического анализа.

В статье /* TODO ссылка */ описывается чистое подмножество языка Cat с правилами вывода, показанными в листинге @cat-rules. При выводе типов алгоритм проходится по словам и находит тип каждой композиции из слов. Затем проводится унификация типов согласно алгоритму Хинди-Милнера.

#листинг(```
pop : ('a -> )
dup : ('a -> 'a 'a)
swap: ('a 'b -> 'b 'a)
if  : ('A bool ('A -> 'B) ('A -> 'B) -> 'B)
eval: ('A ('A -> 'B) -> 'B)
while:('A ('A -> 'A) ('A -> 'A bool) -> 'A)
```)[ Правила вывода некоторых слов в Cat ] <cat-rules>

Статический анализ в Cat не ограничивается проверкой согласованности типов. Поскольку типы фиксируют не только типы элементов, но и форму стека до и после применения функции, система также гарантирует отсутствие недопустимых ситуаций, таких как недостаток аргументов на стеке или несовместимость конфигураций стека в ветвлениях. Для слова условного оператора "if" тип требует, чтобы обе ветви, принимая на вход одну и ту же конфигурацию стека, возвращали стек одинаковой структуры, в противном случае выражение считается некорректным (например, одна ветвь возвращает строку, а другая ― число). Для слова цикла "while" тип требует, чтобы после выполнения цикла конфигурация стека осталось такой же, как была на момнет начала цикла. Дополнительно вводится различие между чистыми и побочными функциями при помощи двух видов стрелок (-> и \~>): функция считается имеющей побочный эффект, если в её реализации используется хотя бы одна побочная операция; эта информация также фиксируется в типах и может использоваться оптимизатором или проверяющими инструментами. Формальная работа по типизации функциональных стековых языков уточняет эту модель, рассматривая подмножество Cat без побочных эффектов, с целыми, булевыми и функциональными типами, и задаёт малошаговую операционную семантику, на фоне которой доказываются свойства корректной типизации и безопасности исполнения.

Управление памятью в Cat опирается на одну из особенностей семантики языка: для каждой функции доступно только то состояние стека, которое существовало на момент вызова этой функции. То есть функция не может ссылаться на предыдущие состояния стека, а значит и использовать данные оттуда. Таким образом можно четко определить время жизни каждого фрагмента данных исходя из знания "в каких конфигурациях стека этот фрагмент данных был, а в каких уже был недоступен".

Благодаря статическому анализу Cat активно работает с оптимизациями и переписыванием программ. На этапе компиляции возможно провести оптимизации константной свертки (вычисление значений, которые зависят только от статического контекста), устранение избыточных стековых операции, композицию цитат (то есть объединение нескольких цитат с целью уменьшения количество операций) и другие.

Область применения Cat складывается из двух направлений. Во-первых, язык используется как исследовательская и учебная платформа для изучения конкатенативного программирования, типовых систем с выводом типов и row-полиморфизма в стековой модели. Работы по типизации функциональных стековых языков прямо опираются на Cat и рассматривают его как эталонный пример статически типизированного конкатенативного языка. Во-вторых, Cat разрабатывается как промежуточный язык для компиляторов и инструментов анализа: статьи и доклады /* TODO ссылки */ подчеркивают его пригодность для формальной верификации, оптимизации и анализа свойств программ на традиционных языках, транслируемых в Cat, особенно в контексте .NET и CIL. Хотя язык не получает широкого промышленного распространения, он влияет на дальнейшие разработки в области конкатенативных языков и типовых систем: упоминания Cat и его системы типов встречаются в описаниях последующих языков (например, Statick и Kitten). В итоге Cat формирует пример полноценно типизированного стекового языка, в котором идея "программа как функция stack → stack, конкатенация как композиция" соединяется с мощной статической системой типов, ориентированной на анализ и оптимизацию.

== ЯП Factor



== ЯП Wasm



== Выводы


