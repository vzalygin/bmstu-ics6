#import "../version.typ": *

= Аналитический обзор существующих решений

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько значимых языков, каждый из которых привнес важные нововведения в группу языков. Для языков рассматриваются аспекты синтаксиса, типизации, работы с памятью и стандартной библиотекой, особенности каждого языка.

== ЯП Forth

Forth представляет собой один из первых стековых конкатенативных языков программирования. Логотип языка представлен на рисунке @forth-logo. Forth создан Чарльзом Муром в начале 1970-х годов как сочетание расширяемого языка и интерактивной методологии разработки. Основная идея состоит в минимальном ядре и словаре «слов» (подпрограмм), через которые реализуется как высокоуровневая логика, так и низкоуровневое аппаратное управление; новые слова добавляются прямо во время работы системы, что позволяет подстраивать язык под конкретную предметную область. Синтаксис несложен: используется обратная польская нотация, программа -- это последовательность слов, разделённых пробелами. Интерпретатор читает токены, ищет их в словаре и либо выполняет связанный код, либо интерпретирует токен как число и кладёт его на стек.

#рис(image("../материалы/forth.png", width: 70%))[ Логотип Forth ] <forth-logo>

С точки зрения семантики типов Forth рассматривается как «безтиповый» @forth-standard: данные представляются машинными словами фиксированной разрядности, а язык не навязывает проверку согласованности типов -- ответственность за корректность интерпретации содержимого стека возлагается на разработчика. Такой подход обеспечивает максимальную гибкость и предсказуемое временное поведение, но затрудняет статический анализ и контроль. Forth применяется в встроенных и ресурсно-ограниченных системах, прошивках, системах реального времени и космической технике: он используется в контроллерах космических аппаратов и приборов NASA, а также в реализациях Open Firmware (стандарт, регламентирующий принцип описания аппаратной конфигурации устройств) для платформ Apple, IBM и Sun. К языка особенностям относятся малый размер полной среды (компилятор, интерпретатор и редактор умещаются в память 8-битных систем), компиляция в нитевой код (представление программы, полностью состоящее из последовательности вызовов подпрограмм) для ускоренной интерпретации, а также единство языка и среды: Forth одновременно служит командной оболочкой, компилятором и минимальной операционной системой, а его стандарт (ANS Forth) описывает лишь набор слов и модель стека, оставляя пользователю свободу строить поверх ядра собственные DSL и диалекты @forth-page.

Стандартной библиотеки у языка в привычном понимании нет -- расширение возможностей происходит за счет включения в среду дополнительных наборов слов.

Определения новых слов задаются конструкцией вида ": NAME ... ;", причём большинство лексем -- от переменных до управляющих конструкций -- являются словами. Стандартный «core word set» ANS Forth @forth-standard включает базовые стековые операции ("DUP", "DROP", "SWAP", "OVER"), арифметику ("+ - \* /"), сравнения, примитивы работы с памятью ("\@" -- чтение по адресу, "!" -- запись по адресу), конструкции ветвления и циклов ("IF … ELSE … THEN", "DO … LOOP"), а также определяющие слова "CREATE", "VARIABLE", "CONSTANT" и др.; остальные word set’ы стандарта являются опциональными расширениями. Почти все управляющие слова в Forth реализуются при помощи понятия слов времени компиляции -- это конструкции, которые во время компиляции компилятор разворачивает в другие слова. Например, конструкция с ветвлением "... DUP 6 < IF DROP 5 ELSE 1 - THEN ..." разворачивается в последовательность слов "... DUP LIT 6 < ?BRANCH 5 DROP LIT 5 BRANCH 3 LIT 1 - ..." -- конструкция условного перехода заменена на слова условного и безусловного переходов @forth-page.

Поскольку Forth является интерактивной средой, процесс исполнения программы можно разделить на 2 составляющие: состояние интерпретации и состояние компиляции. В состоянии интерпретации среда занимается исполнением примитивных слов. В то же время, если среда в процессе встречает некоторый набор слов (например, ":" -- создание нового слова), то она переходит в состояние компиляции и осуществляет разбор подпрограмм, встречаемых синтаксических конструкций. Выполнить переключение состояния также можно при помощи специальных слов "[" -- переход в состояние интерпретации и "]" -- переход в состояние компиляции. 

В листинге @forth-example определяется слово "HELLO", которое затем вызывается и выводит в консоль текст. Круглые кавычки используются для комментариев.

#листинг(```
: HELLO  CR ." Hello, World!" ;
HELLO ( выводит Hello, World! в консоль на следующей строке после вызова слова )
```)[ Определение и использование слова "HELLO" ] <forth-example>

В итоге язык Forth дает ряд возможностей при программировании систем с ограниченными ресурсами. Множество низкоуровневых слов, ряд оптимизаций, точность и гибкость исполнения позволяют писать маленькие и быстрые программы @forth-page.

== ЯП Joy

В 2001 году Манфред фон Тун в La Trobe University представил язык Joy, как попытку формализации логики стековых языков. Joy -- функциональный стековый конкатенативный язык программирования @joy-tut. 

В отличие от обычных функциональных языков, которые строятся вокруг операции применения функции к аргументу, Joy использует операцию композиции функций @joy-math. Каждая программа в Joy обозначает унарную функцию вида "stack -> stack": на вход подаётся состояние (стек данных), в процессе применения команды происходит некая модификация стека и его передача следующей команде, значения и подпрограммы в свою очередь передаются через стек.

С математической точки зрения это формализуется следующим образом: множество всех программ образует синтаксический моноид по операции конкатенации (ассоциативная операция «склейки» программ и пустая программа как нейтральный элемент), а множество функций "stack -> stack" -- семантический моноид по операции композиции и тождественной функции в роли нейтрального элемента @joy-math. Отображение, которое каждой программе сопоставляет её «смысл» (как некоторую функцию над стеком), является гомоморфизмом моноидов, то есть сохраняет операцию: смысл "P Q" равен композиции смыслов "P" и "Q", а смысл пустой программы -- тождественная функция @joy-alg. /* (Моноид здесь понимается в стандартном алгебраическом смысле: набор объектов + одна ассоциативная операция + нейтральный элемент; гомоморфизм -- отображение, которое не ломает эту структуру.)*/

Синтаксис Joy минималистичен и основан на постфиксной записи @joy-tut. Программа -- это последовательность слов, разделённых пробелами, исполнение идёт слева направо. Каждое слово выполняет некоторое преобразование над стеком данных. Операторы (арифметические, логические и другие) снимают одно или несколько значений с вершины стека и помещают результат обратно. Для структур данных используются литералы: списки и цитаты программ записываются в квадратных скобках "[...]", множества -- в фигурных, строки -- в кавычках. Цитата -- это значение, содержащее в себе фрагмент программы как данные, который можно затем анализировать или исполнить @joy-tut. Определения новых слов записываются как равенства: "square == dup \* ." определяет слово "square", которое дублирует вершину стека ("dup") и перемножает два верхних элемента ("\*"). Joy при этом остаётся функционально чистым: стандартные операции не изменяют скрытое глобальное состояние, а только преобразуют стек, так что одну и ту же программу можно рассматривать как математическую функцию "stack -> stack" без побочных эффектов @joy-math.

При построении идиоматических программ на Joy активно используются комбинаторы. В контексте языка это стековые функции, которые принимают одну или несколько цитат программ (списков слов) и управляют их исполнением различными способами @joy-tut. Например, функция-комбинатор "i" ("interpret") берет вершину стека и исполняет список слов, которые лежали внутри вершины. С точки зрения синтаксиса это эквивалентно опусканию скобочек: "[ 1 print ] i" значит то же самое, что и "1 print". Для ветвлений используется комбинатор "ifte", для циклических алгоритмов -- комбинаторы различных схем рекурсии "primrec", "linrec", "binrec". Программист волен создавать и свои функции-комбинаторы на основе уже существующих через механизм определения новых слов. 

Joy является динамически типизированным языком. В язык встроены числовые (целые и вещественные числа), агрегатные типы (строки, списки и неупорядоченные множества) и тип цитат @joy-tut. Типизация стека на этапе компиляции программы никак не контролируется и проверка типов происходит по факту в момент применения той или иной функции. В случае несовпадения ожидаемого и фактического типов выдается ошибка времени выполнения @joy-impl (в отличие от поведения программ на Forth, где произойдет недопустимая реинтерпертация данных и вследствие нее уход неопределенной поведение). Для борьбы с ошибками несовпадения типов рекомендуется к каждому определению в языке приписывать комментарий в следующей нотации: пишется название функции, затем после двоеточия ее эффект на стек -- какой стек функция принимает и какой стек отдает. Например, нотация функции "dup : A -> A A" и функции "+ : Int Int -> Int". Нотация помогает рассмотреть программу как формулу в рамках алгебры стеков (то есть алгебры, которая строится над вычислениями со стеками в качестве переменных) @joy-alg. Такая формализация помогает применять к программам на Joy многие методы теории вычислимости, что является предтечей статического анализа программ.    

Благодаря возможности определять новые слова, которые могут быть комбинаторами или другими функциями, Joy имеет достаточно разветвленную стандартную библиотеку. В стандартной поставке есть несколько библиотек, разбитых по областям применения -- например, "agglib" и "seqlib" содержат обобщенные операции над агрегатами (в контексте языка -- неупорядоченные множества, строки и списки) и последовательностями, "numlib" -- числовые функции и численные методы, "mtrlib" -- функции для работы с матрицами @joy-impl. 

Язык Joy имеет в основном академическое и эксперементальное применением, так как служит для демонстрации применения идей функционального программирования к стековой модели исполнения. Базовая реализация -- интерпретатор на C с автоматической сборкой мусора и набором библиотек. В итоге Joy можно рассматривать как компактную и хорошо формализованную модель стекового языка высокого уровня, где математические понятия моноида и гомоморфизма используются не как абстрактные термины, а как точное описание связи между текстом программы и её поведением при выполнении.

== ЯП Factor

Среди стековых языков Factor занимают нишу языков общего назначения @factor-paper. Первая версия языка была выпущена в 2003 году Славой Пестовым. Логотип языка показан на рисунке @factor-logo. Factor заимствует многие элементы из языка Joy:

- конкатенативный синтаксис;
- использование комбинаторов для управления потока исполнения;
- аналогичный способ создания собственный комбинаторов при помощи цитат.

#рис(image("../материалы/factor.png"))[ Логотип Factor ] <factor-logo>

Как и Joy, Factor является динамически-типизированным языком @factor-paper. Документация и сообщество языка активно используют нотацию "stack effects", при помощи которой описывается, как то или иное слово при применении модифицирует стек. Таким образом оптимизирующий компилятор может проверить объявленные эффекты и отклоняет определения, для которых эффект не удаётся вывести, трактуя это как ошибку компиляции. Внутренний механизм этой проверки описывается как абстрактная интерпретация программы: стек-чекер симулирует эффекты слов на абстрактном стеке, при встрече ветвлений анализирует обе ветви и унифицирует состояния, а несовместимость высоты/формы стека превращается в ошибку времени компиляции. Такая «проверка стека» играет своего рода статический анализатор, который ловит классы ошибок, типичные для стековых языков, и одновременно создаёт фундамент для агрессивных оптимизаций @factor-paper.

В целом язык предлагает множество высокоуровневых и низкоуровневых оптимизаций. Оптимизирующий компилятор состоит оптимизирующего фронтенда, который строит промежуточное представление языка, использующееся для работы стек-чекера и высокоуровневых оптимизаций, а также бекенда, который строит непосредственно исполняемый код для машины, занимается низкоуровневыми оптимизациями @factor-paper.

В отличие от Joy стандратная библиотека Factor обладает гораздо большими размерами и количеством возможностей. Именно благодаря обширной стандартной библиотеке, за счет которой решается множество прикладных задач, язык и носит название прикладного. Также для языка существует большое количество различных инструментов разработки, сопряженные в IDE: интерактивный отладчик, браузер документации, инспектов объектов, механизм модификации программы без ее перезапуска @factor-wiki.

Для работы с памятью язык использует сборщик мусора, встроенный в виртуальную стекову машину языка. Для молодых объектов используется копирующий сборщик, для старшего поколения используется алгоритм "mark-sweep-compact" @factor-paper. Для работы с неуправляемыми ресурсами используются библиотека "destructors" и комбинатор "with-destructors".

В листинге @factor-example показан пример определения слово для вычисления факториала. Наглядно видно использование нотации "stack -> stack" после определения названия слово, а также использование комбинатора "if" и цитат.

#листинг(```
: factorial ( n -- n! )
dup 0 =
[ drop 1 ]
[ dup 1 - factorial * ]
if ;
```)[ Определение слово вычисления факториала ] <factor-example>

== ЯП Cat

Еще одним логическим продолжением Joy является экспериментальный язык Cat (логотип языка показан на рисунке @cat-logo), который с 2006 года разрабатывается Кристофером Диггинсом. Язык используется для верификации и оптимизации программ под платформу .NET CIL @cat-b. Язык наследует идею Joy: любая программа рассматривается как функция вида "stack -> stack", а основная операция ― композиция таких функций, реализуемая простой конкатенацией лексем в исходном тексте программы. Cat вводит статическую систему типов поверх этой модели. Это означает, что в момент компиляции компилятор может вычислить размер стека данных и его типизацию для любого момента времени исполнения программы и верифицировать программу на соответствие ожидаемым типам на стеке и фактическим @cat-b. Таким образом при помощи статического анализа возможно предовратить фатальные ошибки времени выполнения, связанные с несовпадением типов, опустошением или переполнением стека. Также статический анализ открывает дороги агрессивным оптимизациями, которые могут менять тексты программ и промежуточных представлен для повышения производительности.

#рис(image("../материалы/cat.jpg"))[ Логотип Cat ] <cat-logo>

Аналогично Joy, программы на языке Cat опираются на обратную польскую запись с последовательным перечислением слов программы слева направо @cat-b. Работа с поток исполнения устроена при помощи комбинаторов "if" и "while", соответствующих ветвлению и циклу по условию: комбинаторы принимают набор цитат (которые аналогично Joy записываются в квадратных скобках; еще цитаты называют замыканиями) и огранизуют поток управления должным образом. Определение новых слов возможно при помощи слова "define" -- определение слов глобально и единственно (множественные определения запрещены).

В множестве команд языка доступны арифметические, логические операции, операции сравнения, операции манипуляции стеком и наконец комбинаторы (или же, как привычнее для Cat, -- функции высшего порядка). Также существуют примиты работы с последовательностями, рекурсивными алгоритмами.

Наибольшего внимания заслуживает система типов Cat, благодаря которой язык обзавелся статическим анализом. Система типов Cat описывает поведение функций в терминах потребления и производства элементов стека. Тип функции определяется тем, что функция ожидает на стеке перед началом выполнения, и тем, что она оставляется на стеке после выполнения. Тип записывается как стрелка между конфигурациями стека @cat-a, например "(int int -> int)" для операции сложения или "('a 'S -> 'a 'a 'S)" для дублирования вершины стека. Слева указываются типы, которые должны находиться на вершине входного стека, справа ― типы элементов на вершине выходного стека. Типы с апострофом ('a, 'b) обозначают типовые переменные (для которых точный тип не специализирован из-за ненадобности), а специальные "типовые векторы", обозначаемые заглавными буквами ('A, 'B), представляют произвольные последовательности типов, то есть "хвост" стека. Такое представление соответствует row-полиморфизму: каждая функция не только определяет, какие значения она снимает и кладёт на вершину стека, но и неявно пропускает через себя остальную часть стека, обозначаемую переменной "ряда" типа; это позволяет типизировать локальные преобразования независимо от длины и состава "фона" стека. Диггинс формализует эту систему через различие между "родами" (kinds) для обычных типов и для стеков значений: типы значений и типы стеков образуют две категории, между которыми определяются функции "stack -> stack", а типизация выражается в виде правил натурального вывода (правила, которые задают соответствие между набором посылок -- входной конфигурацей стека и выводом из этого -- выходной конфигурацией стека; для каждого слова определен свой набор таких правил) и полиморфной системы родов, позволяющей описывать как отдельные значения, так и целые стековые конфигурации @cat-a. Вывод типов на основе правил в Cat базируется на вариации алгоритма Хиндли--Милнера, обобщённой на стековые типы и row-полиморфизм, причём языковые конструкции допускают полиморфизм более высоких рангов (то есть возможен логический вывод для программ, где используются функции высшего порядка), а аннотации типов (так называемые "stack diagrams") используются как документация и как данные для статического анализа @cat-a.

В статье @cat-b описывается чистое подмножество языка Cat с правилами вывода, показанными в листинге @cat-rules. При выводе типов алгоритм проходится по словам и находит тип каждой композиции из слов. Затем проводится унификация типов согласно алгоритму Хинди-Милнера.

#листинг(```
pop : ('a -> )
dup : ('a -> 'a 'a)
swap: ('a 'b -> 'b 'a)
if  : ('A bool ('A -> 'B) ('A -> 'B) -> 'B)
eval: ('A ('A -> 'B) -> 'B)
while:('A ('A -> 'A) ('A -> 'A bool) -> 'A)
```)[ Правила вывода основных слов в Cat ] <cat-rules>

Статический анализ в Cat не ограничивается проверкой согласованности типов. Поскольку типы фиксируют не только типы элементов, но и форму стека до и после применения функции, система также гарантирует отсутствие недопустимых ситуаций, таких как недостаток аргументов на стеке или несовместимость конфигураций стека в ветвлениях @cat-a. Для слова условного оператора "if" тип требует, чтобы обе ветви, принимая на вход одну и ту же конфигурацию стека, возвращали стек одинаковой структуры, в противном случае выражение считается некорректным (например, одна ветвь возвращает строку, а другая ― число). Для слова цикла "while" тип требует, чтобы после выполнения цикла конфигурация стека осталось такой же, как была на момент начала цикла. Дополнительно вводится различие между чистыми и побочными функциями при помощи двух видов стрелок (-> и \~>): функция считается имеющей побочный эффект, если в её реализации используется хотя бы одна побочная операция @cat-a. Эта информация также фиксируется в типах и может использоваться оптимизатором или проверяющими инструментами.

Область применения Cat складывается из двух направлений. Во-первых, язык используется как исследовательская и учебная платформа для изучения конкатенативного программирования, типовых систем с выводом типов и row-полиморфизма в стековой модели. Работы по типизации функциональных стековых языков прямо опираются на Cat и рассматривают его как эталонный пример статически типизированного конкатенативного языка. Во-вторых, Cat разрабатывается как промежуточный язык для компиляторов и инструментов анализа. Хотя язык не получает широкого промышленного распространения, он влияет на дальнейшие разработки в области конкатенативных языков и типовых систем. В итоге Cat формирует пример полноценно типизированного стекового языка, в котором идея "программа как функция stack → stack, конкатенация как композиция" соединяется с сильной статической системой типов, ориентированной на анализ и оптимизацию.

== ЯП Wasm

В 2017 году группа компаний, в которую входит W3C, Mozilla, Google, Microsoft, Apple, представила язык WebAssebmly (Wasm). Логотип Wasm показан на рисунке @wasm-logo. Wasm представляет собой низкоуровневый переносимый байткод (набор под виртуальную стековую машину, запускаемую преимуществено (но не только) в веб-браузерах наравне с движками EcmaScript для исполнения клиентского кода @wasm-spec. Это первый из представленных в обзоре языков, который являются целью компиляции, а не сам компилируется во что-либо. Поддержка компиляции в Wasm имеется для множества высокоуровневых языков: в первую очередь для таких как C/C++/Rust, которые имеют маленький (или вообще не имеют) рантайм. В исходных целях проектирования Wasm фиксируются требования к компактности двоичного представления, быстрой однопроходной валидации и компиляции, а также к «песочнице» с предсказуемой семантикой, пригодной для запуска недоверенного кода @wasm-spec.

#рис(image("../материалы/wasm.png", height: 15%))[ Логотип Wasm ] <wasm-logo>

Байткод на Wasm в основном поставляется в виде бинарного представления, которое в то же время возможно транслировать в текстовое человеко-читаемое представление. Текстовый вариант основан на записи S-выражений @wasm-syntax (еще одна черта, которая отличает этот язык от представленных ранее). Листинг @wasm-example показывает определение функции сложения числа с самим собой на wasm в человеко-читаемом варианте.

#листинг(```
(func (param $p i32)
  (result i32)
  local.get $p
  local.get $p
  i32.add
)
```)[ Определение функции сложения числа с самим собой ] <wasm-example>

Как стековый язык исполнения Wasm опирается на неявный операндный стек и структурированное управление потоком @wasm-spec. Инструкции потребляют значения с вершины стека и помещают результаты обратно, при этом реализация не обязана хранить "настоящий" стек: спецификация прямо описывает интерпретацию стека как набора анонимных регистров, а статическая типовая проверка делает высоту стека известной на этапах валидации и компиляции. Управление потоком задаётся структурными конструкциями (block, loop, if) и переходами к меткам (br, br_if, br_table). Единица трансляции Wasm называется модулем @wasm-spec.

Типизация в Wasm является статической и рассчитана на проверку до исполнения. Функции имеют явные типы параметров и результатов, инструкции типизируются через эффекты над стеком (как и в языке Cat), а модуль проходит валидацию, гарантирующую корректность применения инструкций к операндам нужных типов и отсутствие underflow ошибок. Верификация модуля происходит за один проход @wasm-spec, что соответствует целям языка по скорости исполнения.

Язык и вирутальная машина используются в качестве безопасной песочницы с производительностью низкоуровневого кода, в основном исполняемой в веб-браузерах. По сравнению с традиционным для браузеров языком EcmaScript, низкоуровневый стековый байткод занимает меньше пространства и быстрее работает, так как требует меньше накладных расходов (по сравнению с движками EcmaScript, например, V8).

Поскольку язык является низкоуровневым, понятие стандартной библиотеки к нему не применяется. Вместо встроенных API используется модель импортов: окружение предоставляет функции и объекты, а модуль экспортирует точки входа.

Управление памятью осуществляется в ручном режиме: так как язык Wasm является целью компиляции, то ответственность за гарантии при работе с памятью ложится на средства исходного языка @wasm-spec (такие как статические проверки Rust, сборщики мусора или, в случае, например, C/C++ сами разработчики ПО).

== Выводы

Вышеописанные обзоры языков позволяют проследить эволюцию стековых языков. Начавшись с близкого к аппаратной части Forth, они и заложенные в них идеи развились и со временем нашли применение в самых разных системах: от встраиваемого ПО до современных виртуальных машин и форматов переносимого кода. Основными свойстваим стековых языков счиаются простота реализации и переносимости, возможность строгой верификации корректности программ, а также минимальные накладные расходы рантайма.

Рассмотренные языки со временем приобретают большие возможности статического анализа, что открывает дополнительные возможности верификации и оптимизации программ. Благодаря этому стековые языки становятся быстре и безопаснее для использования, что вместе с изначально им присущей высокой переносимостью и простой реализации стековой машины, дает большие преимущества в развитии как низкоуровневых языков для различного рода машин.

Таблица @обзор собирает структурирует информацию об вышеописанных языках.

#таблица(table(
  columns: (.7fr, 1fr, 1.2fr, 1.75fr, 1.3fr, 1.3fr),
  // columns: (auto, auto,auto,auto,auto,auto),
  table.header(
  text(size:10pt)[Язык],
  text(size:10pt)[Синтаксис],
  text(size:10pt)[Типизация],
  text(size:10pt)[Анализ и оптимизации],
  text(size:10pt)[Стандартная библиотека],
  text(size:10pt)[Область применения],
  ),
  text(size:10pt)[Forth,\ 1970],
  text(size:10pt)[Постфиксный конкатенативный],
  text(size:10pt)[Безтиповой],
  text(size:10pt)[Наличие базовых оптимизаций (нитевой код), статического анализа нет],
  text(size:10pt)[Наборы слов (ANS core + расширения)],
  text(size:10pt)[Встроенные системы],

  text(size:10pt)[Joy,\ 2001],
  text(size:10pt)[Постфиксный конкатенативный],
  text(size:10pt)[Динамическая типизациция],
  text(size:10pt)[Задана формальная модель языка],
  text(size:10pt)[Базовые слова + библиотеки слов],
  text(size:10pt)[Экспериментальный язык],

  text(size:10pt)[Factor,\ 2003],
  text(size:10pt)[Постфиксный конкатенативный],
  text(size:10pt)[Динамическая типизация],
  text(size:10pt)[Есть stack-checker и агрессивные оптимизации],
  text(size:10pt)[Обширная стандратная библиотека и инструментарий разработки],
  text(size:10pt)[Язык общего назначения],

  text(size:10pt)[Cat,\ 2006],
  text(size:10pt)[Постфиксный конкатенативный],
  text(size:10pt)[Статическая типизация стека по форме и размеру],
  text(size:10pt)[Статический вывод типов и эффектов стека, верификация программ],
  text(size:10pt)[Минимальная стандратная библиотека],
  text(size:10pt)[Эксперементальный язык, верификация программ .NET CIL],

  text(size:10pt)[Wasm, 2017],
  text(size:10pt)[S-выражения],
  text(size:10pt)[Статическая типизация],
  text(size:10pt)[Статический анализ за один проход, верификация, JIT/AOT оптимизации в рантайме],
  text(size:10pt)[Нет, но есть импортируемые API],
  text(size:10pt)[Цель компиляции для Web-среды и изолированных рантаймов],
))[ Сводная характеристика рассмотренных стековых языков ] <обзор>
