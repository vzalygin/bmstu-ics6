#import "../version.typ": *

= Аналитический обзор существующих решений

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько значимых языков, каждый из которых привнес важные нововведения в группу языков. Для языков рассматриваются аспекты синтаксиса, типизации, работы с памятью и стандартной библиотекой, особенности каждого языка.

== ЯП Forth

Forth представляет собой один из первых стековых конкатенативных языков программирования. Логотип языка представлен на рисунке @forth-logo. Forth создан Чарльзом Муром в начале 1970-х годов как сочетание расширяемого языка и интерактивной методологии разработки. Основная идея состоит в минимальном ядре и словаре «слов» (подпрограмм), через которые реализуется как высокоуровневая логика, так и низкоуровневое аппаратное управление; новые слова добавляются прямо во время работы системы, что позволяет подстраивать язык под конкретную предметную область. Синтаксис несложен: используется обратная польская нотация, программа -- это последовательность слов, разделённых пробелами. Интерпретатор читает токены, ищет их в словаре и либо выполняет связанный код, либо интерпретирует токен как число и кладёт его на стек.

#рис(image("../материалы/forth.png", width: 70%))[ Логотип Forth ] <forth-logo>

С точки зрения семантики типов Forth рассматривается как «безтиповый»: данные представляются машинными словами фиксированной разрядности, а язык не навязывает проверку согласованности типов -- ответственность за корректность интерпретации содержимого стека возлагается на разработчика. Такой подход обеспечивает максимальную гибкость и предсказуемое временное поведение, но затрудняет статический анализ и контроль. Forth применяется в встроенных и ресурсно-ограниченных системах, прошивках, системах реального времени и космической технике: он используется в контроллерах космических аппаратов и приборов NASA, а также в реализациях Open Firmware (стандарт, регламентирующий принцип описания аппаратной конфигурации устройств) для платформ Apple, IBM и Sun. К языка особенностям относятся малый размер полной среды (компилятор, интерпретатор и редактор умещаются в память 8-битных систем), компиляция в нитевой код (представление программы, полностью состоящее из последовательности вызовов подпрограмм) для ускоренной интерпретации, а также единство языка и среды: Forth одновременно служит командной оболочкой, компилятором и минимальной операционной системой, а его стандарт (ANS Forth) описывает лишь набор слов и модель стека, оставляя пользователю свободу строить поверх ядра собственные DSL и диалекты.

Стандартной библиотеки у языка в привычном понимании нет -- расширение возможностей происходит за счет включения в среду дополнительных наборов слов.

Определения новых слов задаются конструкцией вида ": NAME ... ;", причём большинство лексем -- от переменных до управляющих конструкций -- являются словами. Стандартный «core word set» ANS Forth включает базовые стековые операции ("DUP", "DROP", "SWAP", "OVER"), арифметику ("+ - \* /"), сравнения, примитивы работы с памятью ("\@" -- чтение по адресу, "!" -- запись по адресу), конструкции ветвления и циклов ("IF … ELSE … THEN", "DO … LOOP"), а также определяющие слова "CREATE", "VARIABLE", "CONSTANT" и др.; остальные word set’ы стандарта являются опциональными расширениями. Почти все управляющие слова в Forth реализуются при помощи понятия слов времени компиляции -- это конструкции, которые во время компиляции компилятор разворачивает в другие слова. Например, конструкция с ветвлением "... DUP 6 < IF DROP 5 ELSE 1 - THEN ..." разворачивается в последовательность слов "... DUP LIT 6 < ?BRANCH 5 DROP LIT 5 BRANCH 3 LIT 1 - ..." -- конструкция условного перехода заменена на слова условного и безусловного переходов.

Поскольку Forth является интерактивной средой, процесс исполнения программы можно разделить на 2 составляющие: состояние интерпретации и состояние компиляции. В состоянии интерпретации среда занимается исполнением примитивных слов. В то же время, если среда в процессе встречает некоторый набор слов (например, ":" -- создание нового слова), то она переходит в состояние компиляции и осуществляет разбор подпрограмм, встречаемых синтаксических конструкций. Выполнить переключение состояния также можно при помощи специальных слов "[" -- переход в состояние интерпретации и "]" -- переход в состояние компиляции. 

В листинге @forth-example определяется слово "HELLO", которое затем вызывается и выводит в консоль текст. Круглые кавычки используются для комментариев.

#листинг(```
: HELLO  CR ." Hello, World!" ;
HELLO ( выводит Hello, World! в консоль на следующей строке после вызова слова )
```)[ Определение и использование слова "HELLO" ] <forth-example>

В итоге язык Forth дает ряд возможностей при программировании систем с ограниченными ресурсами. Множество низкоуровневых слов, ряд оптимизаций, точность и гибкость исполнения позволяют писать маленькие и быстрые программы.

== ЯП Joy

В 2001 году Манфред фон Тун в La Trobe University представил язык Joy, как попытку формализации логики стековых языков. Joy -- функциональный стековый конкатенативный язык программирования. 

В отличие от обычных функциональных языков, которые строятся вокруг операции применения функции к аргументу, Joy использует операцию композиции функций. Каждая программа в Joy обозначает унарную функцию вида "stack -> stack": на вход подаётся состояние (стек данных), в процессе применения команды происходит некая модификация стека и его передача следующей команде, значения и подпрограммы в свою очередь передаются через стек.

С математической точки зрения это формализуется следующим образом: множество всех программ образует синтаксический моноид по операции конкатенации (ассоциативная операция «склейки» программ и пустая программа как нейтральный элемент), а множество функций "stack -> stack" — семантический моноид по операции композиции и тождественной функции в роли нейтрального элемента. Отображение, которое каждой программе сопоставляет её «смысл» (как некоторую функцию над стеком), является гомоморфизмом моноидов, то есть сохраняет операцию: смысл "P Q" равен композиции смыслов "P" и "Q", а смысл пустой программы — тождественная функция. /* (Моноид здесь понимается в стандартном алгебраическом смысле: набор объектов + одна ассоциативная операция + нейтральный элемент; гомоморфизм — отображение, которое не ломает эту структуру.)*/

Синтаксис Joy минималистичен и основан на постфиксной записи. Программа — это последовательность слов, разделённых пробелами, исполнение идёт слева направо. Каждое слово выполняет некоторое преобразование над стеком данных. Операторы (арифметические, логические и другие) снимают одно или несколько значений с вершины стека и помещают результат обратно. Для структур данных используются литералы: списки и цитаты программ записываются в квадратных скобках "[...]", множества — в фигурных, строки — в кавычках. Цитата — это значение, содержащее в себе фрагмент программы как данные, который можно затем анализировать или исполнить. Определения новых слов записываются как равенства: "square == dup \* ." определяет слово "square", которое дублирует вершину стека ("dup") и перемножает два верхних элемента ("\*"). Joy при этом остаётся функционально чистым: стандартные операции не изменяют скрытое глобальное состояние, а только преобразуют стек, так что одну и ту же программу можно рассматривать как математическую функцию "stack -> stack" без побочных эффектов.

При построении идиоматических программ на Joy активно используются комбинаторы. В контексте языка это стековые функции, которые принимают одну или несколько цитат программ (списков слов) и управляют их исполнением различными способами. Например, функция-комбинатор "i" ("interpret") берет вершину стека и исполняет список слов, которые лежали внутри вершины. С точки зрения синтаксиса это эквивалентно опусканию скобочек: "[ 1 print ] i" значит то же самое, что и "1 print". Для ветвлений используется комбинатор "ifte", для циклических алгоритмов -- комбинаторы различных схем рекурсии "primrec", "linrec", "binrec". Программист волен создавать и свои функции-комбинаторы на основе уже существующих через механизм определения новых слов. 

Joy является динамически типизированным языком. В язык встроены числовые (целые и вещественные числа), агрегатные типы (строки, списки и неупорядоченные множества) и тип цитат. Типизация стека на этапе компиляции программы никак не контролируется и проверка типов происходит по факту в момент применения той или иной функции. В случае несовпадения ожидаемого и фактического типов выдается ошибка времени выполнения (в отличие от поведения программ на Forth, где произойдет недопустимая реинтерпертация данных и вследствие нее уход неопределенной поведение). Для борьбы с ошибками несовпадения типов рекомендуется к каждому определению в языке приписывать комментарий в следующей нотации: пишется название функции, затем после двоеточия ее эффект на стек -- какой стек функция принимает и какой стек отдает. Например, нотация функции "dup : A -> A A" и функции "+ : Int Int -> Int". Нотация помогает рассмотреть программу как формулу в рамках алгебры стеков (то есть алгебры, которая строится над вычислениями со стеками в качестве переменных). Такая формализация помогает применять к программам на Joy многие методы теории вычислимости, что является предтечей статического анализа программ.    

Благодаря возможности определять новые слова, которые могут быть комбинаторами или другими функциями, Joy имеет богатую стандартную библиотеку. В стандартной поставке есть несколько библиотек, разбитых по областям применения -- например, "agglib" и "seqlib" содержат обобщенные операции над агрегатами (в контексте языка -- неупорядоченные множества, строки и списки) и последовательностями, "numlib" -- числовые функции и численные методы, "mtrlib" -- функции для работы с матрицами. 

Язык Joy имеет в основном академическое и эксперементальное применением, так как служит для демонстрации применения идей функционального программирования к стековой модели исполнения. Базовая реализация -- интерпретатор на C с автоматической сборкой мусора и набором библиотек. В итоге Joy можно рассматривать как компактную и хорошо формализованную модель стекового языка высокого уровня, где математические понятия моноида и гомоморфизма используются не как абстрактные термины, а как точное описание связи между текстом программы и её поведением при выполнении.

== ЯП Factor

Среди стековых языков Factor занимают нишу языков общего назначения. Первая версия языка была выпущена в 2003 году Славой Пестовым. Логотип языка показан на рисунке @factor-logo. Factor заимствует многие элементы из языка Joy:

- конкатенативный синтаксис;
- использование комбинаторов для управления потока исполнения;
- аналогичный способ создания собственный комбинаторов при помощи цитат.

#рис(image("../материалы/factor.png"))[ Логотип Factor ] <factor-logo>

Как и Joy, Factor является динамически-типизированным языком. Документация и сообщество языка активно используют нотацию "stack effects", при помощи которой описывается, как то или иное слово при применении модифицирует стек. Таким образом оптимизирующий компилятор может проверить объявленные эффекты и отклоняет определения, для которых эффект не удаётся вывести, трактуя это как ошибку компиляции. Внутренний механизм этой проверки описывается как абстрактная интерпретация программы: стек-чекер симулирует эффекты слов на абстрактном стеке, при встрече ветвлений анализирует обе ветви и унифицирует состояния, а несовместимость высоты/формы стека превращается в ошибку времени компиляции. Такая «проверка стека» играет в своего рода статический анализатор, который ловит классы ошибок, типичные для стековых языков, и одновременно создаёт фундамент для агрессивных оптимизаций.

В целом язык предлагает множество высокоуровневых и низкоуровневых оптимизаций. Оптимизирующий компилятор состоит оптимизирующего фронтенда, который строит промежуточное представление языка, использующееся для работы стек-чекера и высокоуровневых оптимизаций, а также бекенда, который строит непосредственно исполняемый код для машины, занимается низкоуровневыми оптимизациями.

В отличие от Joy стандратная библиотека Factor обладает гораздо большими размерами и количеством возможностей. Именно за счет обширной стандартной библиотеки, за счет которой решается множество прикладных задач, язык и носит название прикладного. Также для языка существует большое количество различных инструментов разработки, сопряженные в IDE: интерактивный отладчик, браузер документации, инспектов объектов, механизм модификации программы без ее перезапуска.

Для работы с памятью язык использует сборщик мусора, встроенный в виртуальную стекову машину языка. Для молодых объектов используется копирующий сборщик, для старшего поколения используется алгоритм "mark-sweep-compact". Для работы с неуправляемыми ресурсами используются библиотека "destructors" и комбинатор "with-destructors".

В листинге @factor-example показан пример определения слово для вычисления факториала. Наглядно видно использование нотации "stack -> stack" после определения названия слово, а также использование комбинатора "if" и цитат.

#листинг(```
: factorial ( n -- n! )
dup 0 =
[ drop 1 ]
[ dup 1 - factorial * ]
if ;
```)[ Определение слово вычисления факториала ] <factor-example>

== ЯП Cat

Еще одним логическим продолжением Joy является экспериментальный язык Cat (логотип языка показан на рисунке @cat-logo), который с 2006 года разрабатывается Кристофером Диггинсом. Язык используется для верификации и оптимизации программ под платформу .NET CIL. Язык наследует идею Joy: любая программа рассматривается как функция вида "stack -> stack", а основная операция ― композиция таких функций, реализуемая простой конкатенацией лексем в исходном тексте программы. Cat вводит статическую систему типов поверх этой модели. Это означает, что в момент компиляции компилятор может вычислить размер стека программы и верифицировать программу на соответствие ожидаемым типам на стеке и фактическим. Таким образом при помощи статического анализа возможно предовратить фатальные ошибки времени выполнения, связанные с несовпадением типов, опустошением или переполнением стека. Также статический анализ открывает дороги агрессивным оптимизациями, которые могут менять тексты программ и промежуточных представлен для повышения производительности.

#рис(image("../материалы/cat.jpg"))[ Логотип Cat ] <cat-logo>

Аналогично Joy, программы на языке Cat опираются на обратную польскую запись с последовательным перечислением слов программы слева направо. Работа с поток исполнения устроена при помощи комбинаторов "if" и "while", соответствующих ветвлению и циклу по условию: комбинаторы принимают набор цитат (которые аналогично Joy записываются в квадратных скобках; еще цитаты называют замыканиями) и огранизуют поток управления должным образом. Определение новых слов возможно при помощи слова "define" -- определение слов глобально и единственно (множественные определения запрещены).

В множестве команд языка доступны арифметические, логические операции, операции сравнения, операции манипуляции стеком и наконец комбинаторы (или же, как привычнее для Cat, -- функции высшего порядка). Также существуют примиты работы с последовательностями, рекурсивными алгоритмами.

Наибольшего внимания заслуживает система типов Cat, благодаря которой язык обзавелся статическим анализом. Система типов Cat описывает поведение функций в терминах потребления и производства элементов стека. Тип функции определяется тем, что функция ожидает на стеке перед началом выполнения, и тем, что она оставляется на стеке после выполнения. Тип записывается как стрелка между конфигурациями стека, например "(int int -> int)" для операции сложения или "('a 'S -> 'a 'a 'S)" для дублирования вершины стека. Слева указываются типы, которые должны находиться на вершине входного стека, справа ― типы элементов на вершине выходного стека. Типы с апострофом ('a, 'b) обозначают типовые переменные (для которых точный тип не специализирован из-за ненадобности), а специальные "типовые векторы", обозначаемые заглавными буквами ('A, 'B), представляют произвольные последовательности типов, то есть "хвост" стека. Такое представление соответствует row-полиморфизму: каждая функция не только определяет, какие значения она снимает и кладёт на вершину стека, но и неявно пропускает через себя остальную часть стека, обозначаемую переменной "ряда" типа; это позволяет типизировать локальные преобразования независимо от длины и состава "фона" стека. Статья о типизации функциональных стековых языков формализует эту систему через различие между "родами" (kinds) для обычных типов и для стеков значений: типы значений и типы стеков образуют две категории, между которыми определяются функции "stack -> stack", а типизация выражается в виде правил натурального вывода (правила, которые задают соответствие между набором посылок -- входной конфигурацей стека и выводом из этого -- выходной конфигурацией стека; для каждого слова определен свой набор таких правил) и полиморфной системы родов, позволяющей описывать как отдельные значения, так и целые стековые конфигурации. Вывод типов на основе правил в Cat базируется на вариации алгоритма Хиндли--Милнера, обобщённой на стековые типы и row-полиморфизм, причём языковые конструкции допускают полиморфизм более высоких рангов (то есть возможен логический вывод даже для программ, где используются функции высшего порядка), а аннотации типов (так называемые "stack diagrams") используются как документация и как данные для статического анализа.

В статье /* TODO ссылка */ описывается чистое подмножество языка Cat с правилами вывода, показанными в листинге @cat-rules. При выводе типов алгоритм проходится по словам и находит тип каждой композиции из слов. Затем проводится унификация типов согласно алгоритму Хинди-Милнера.

#листинг(```
pop : ('a -> )
dup : ('a -> 'a 'a)
swap: ('a 'b -> 'b 'a)
if  : ('A bool ('A -> 'B) ('A -> 'B) -> 'B)
eval: ('A ('A -> 'B) -> 'B)
while:('A ('A -> 'A) ('A -> 'A bool) -> 'A)
```)[ Правила вывода основных слов в Cat ] <cat-rules>

Статический анализ в Cat не ограничивается проверкой согласованности типов. Поскольку типы фиксируют не только типы элементов, но и форму стека до и после применения функции, система также гарантирует отсутствие недопустимых ситуаций, таких как недостаток аргументов на стеке или несовместимость конфигураций стека в ветвлениях. Для слова условного оператора "if" тип требует, чтобы обе ветви, принимая на вход одну и ту же конфигурацию стека, возвращали стек одинаковой структуры, в противном случае выражение считается некорректным (например, одна ветвь возвращает строку, а другая ― число). Для слова цикла "while" тип требует, чтобы после выполнения цикла конфигурация стека осталось такой же, как была на момнет начала цикла. Дополнительно вводится различие между чистыми и побочными функциями при помощи двух видов стрелок (-> и \~>): функция считается имеющей побочный эффект, если в её реализации используется хотя бы одна побочная операция; эта информация также фиксируется в типах и может использоваться оптимизатором или проверяющими инструментами. Формальная работа по типизации функциональных стековых языков уточняет эту модель, рассматривая подмножество Cat без побочных эффектов, с целыми, булевыми и функциональными типами, и задаёт малошаговую операционную семантику, на фоне которой доказываются свойства корректной типизации и безопасности исполнения.

Управление памятью в Cat опирается на одну из особенностей семантики языка: для каждой функции доступно только то состояние стека, которое существовало на момент вызова этой функции. То есть функция не может ссылаться на предыдущие состояния стека, а значит и использовать данные оттуда. Таким образом можно четко определить время жизни каждого фрагмента данных исходя из знания "в каких конфигурациях стека этот фрагмент данных был, а в каких уже был недоступен".

Благодаря статическому анализу Cat активно работает с оптимизациями и переписыванием программ. На этапе компиляции возможно провести оптимизации константной свертки (вычисление значений, которые зависят только от статического контекста), устранение избыточных стековых операции, композицию цитат (то есть объединение нескольких цитат в одну с целью уменьшения количество операций) и другие.

Область применения Cat складывается из двух направлений. Во-первых, язык используется как исследовательская и учебная платформа для изучения конкатенативного программирования, типовых систем с выводом типов и row-полиморфизма в стековой модели. Работы по типизации функциональных стековых языков прямо опираются на Cat и рассматривают его как эталонный пример статически типизированного конкатенативного языка. Во-вторых, Cat разрабатывается как промежуточный язык для компиляторов и инструментов анализа: статьи и доклады /* TODO ссылки */ подчеркивают его пригодность для формальной верификации, оптимизации и анализа свойств программ на традиционных языках, транслируемых в Cat, особенно в контексте .NET и CIL. Хотя язык не получает широкого промышленного распространения, он влияет на дальнейшие разработки в области конкатенативных языков и типовых систем: упоминания Cat и его системы типов встречаются в описаниях последующих языков (например, Statick и Kitten). В итоге Cat формирует пример полноценно типизированного стекового языка, в котором идея "программа как функция stack → stack, конкатенация как композиция" соединяется с мощной статической системой типов, ориентированной на анализ и оптимизацию.

== ЯП Wasm

В 2017 году группа компаний, в которую входит W3C, Mozilla, Google, Microsoft, Apple, представила язык WebAssebmly (Wasm). Логотип Wasm показан на рисунке @wasm-logo. Wasm представляет собой низкоуровневый переносимый байткод (набор под виртуальную стековую машину, запускаемую преимуществено (но не только) в веб-браузерах наравне с движками EcmaScript для исполнения клиентского кода. Это первый из представленных в обзоре языков, который являются целью компиляции, а не сам компилируется во что-либо. Поддержка компиляции в Wasm имеется для множества высокоуровневых языков: в первую очередь для таких как C/C++/Rust, которые имеют маленький (или вообще не имеют) рантайм. В исходных целях проектирования Wasm фиксируются требования к компактности двоичного представления, быстрой однопроходной валидации и компиляции, а также к «песочнице» с предсказуемой семантикой, пригодной для запуска недоверенного кода.

#рис(image("../материалы/wasm.png", height: 15%))[ Логотип Wasm ] <wasm-logo>

Байткод на Wasm в основном поставляется в виде бинарного представления, которое в то же время возможно транслировать в текстовое человеко-читаемое представление. Текстовый вариант основан на записи S-выражений (еще одна черта, которая отличает этот язык от представленных ранее). Листинг @wasm-example показывает определение функции сложения числа с самим собой на wasm в человеко-читаемом варианте.

#листинг(```
(func (param $p i32)
  (result i32)
  local.get $p
  local.get $p
  i32.add
)
```)[ Определение функции сложения числа с самим собой ] <wasm-example>

Как стековый язык исполнения Wasm опирается на неявный операндный стек и структурированное управление потоком. Инструкции потребляют значения с вершины стека и помещают результаты обратно, при этом реализация не обязана хранить "настоящий" стек: спецификация прямо описывает интерпретацию стека как набора анонимных регистров, а статическая типовая проверка делает высоту стека известной на этапах валидации и компиляции. Управление потоком задаётся структурными конструкциями (block, loop, if) и переходами к меткам (br, br_if, br_table). Единица трансляции Wasm называется модулем.

Типизация в Wasm является статической и рассчитана на проверку до исполнения. Функции имеют явные типы параметров и результатов, инструкции типизируются через эффекты над стеком (как и в языке Cat), а модуль проходит валидацию, гарантирующую корректность применения инструкций к операндам нужных типов и отсутствие underflow ошибок. Верификация модуля происходит за один проход, что соответствует целям языка по скорости исполнения.

Язык и вирутальная машина используются в качестве безопасной песочницы с производительностью низкоуровневого кода, в основном исполняемой в веб-браузерах. По сравнению с традиционным для браузеров языком EcmaScript, низкоуровневый стековый байткод занимает меньше пространства и быстрее работает, так как требует меньше накладных расходов (по сравнению с движками EcmaScript, например, V8).

Поскольку язык является низкоуровневым, понятие стандартной библиотеки к нему не применяется. Вместо встроенных API используется модель импортов: окружение предоставляет функции и объекты, а модуль экспортирует точки входа.

Управление памятью осуществляется в ручном режиме: так как язык Wasm является целью компиляции, то ответственность за гарантии при работе с памятью ложится на средства исходного языка (такие как статические проверки Rust, сборщики мусора или, в случае, например, C/C++ сами разработчики ПО).

== Выводы

Исходя из описанных 
