#import "../version.typ": *

= Сравнительный анализ

Для обеспечения полноты работы выполнен сравнительный анализ синтаксических свойств рассмотренных языков. 

С точки зрения синтаксиса Forth, Joy, Cat и Factor относятся к конкатенативным языкам: программа представляется как последовательность "слов" (токенов), разделённых пробелами, а композиция вычислений выражается простой конкатенацией лексем. При этом языки различаются механизмами построения составных выражений:

- Forth опирается на режимы состояния;
- Joy, Cat и производные активно используют цитаты (фрагменты программы как данные);
- Factor дополняет язык соглашением "stack effects".

Wasm занимает отдельное место. Основной формат является бинарным, однако предусмотрено человеко-читаемое представление, основанное на S-выражениях. Поэтому по "форме записи" Wasm отличается от конкатенативных языков высокого уровня: в WAT структура задаётся скобочной формой, хотя сами инструкции по смыслу остаются стековыми (так как операндный стек неявен) @wasm-spec @wasm-syntax. 

Таблица с сравнительным анализом языков по синтаксису представлена в таблице @syntax-compare.

#таблица(table(
  columns: (0.85fr, 1fr, 1.6fr),
  table.header(
    [Язык],
    [Базовая форма\ записи],
    // [Определение новых слов/функций],
    // [Составные конструкции],
    [Ключевые особенности синтаксиса],
  ),

  block(breakable: false)[Forth],
  block(breakable: false)[Постфиксная],
  // [": NAME ... ;"],
  // [комментарии "( ... )", "\" ..."; строки ".\" ...\""],
  block(breakable: false)[Управляющие конструкции реализуются как слова времени компиляции],

  block(breakable: false)[Joy],
  block(breakable: false)[Постфиксная],
  // ["name == ... ."],
  // [цитаты/списки "[ ... ]"; множества "{ ... }"; строки "..." ],
  block(breakable: false)[Цитаты используются как данные, управление через комбинаторы ("i", "ifte", "primrec/linrec/binrec")],

  block(breakable: false)[Cat],
  block(breakable: false)[Постфиксная],
  // ["define name ... ;" (глобально и единственно)],
  // [цитаты/замыкания "[ ... ]"; комбинаторы "if", "while"],
  block(breakable: false)[Синтаксис близок к Joy],

  block(breakable: false)[Factor],
  block(breakable: false)[Постфиксная],
  // [": name ( ... -- ... ) ... ;"],
  // [цитаты "[ ... ]"; нотация "stack effects" как часть определения],
  block(breakable: false)[Обязательная документация эффектов стека],

  block(breakable: false)[Wasm],
  block(breakable: false)[S-выражения],
  // [(func ...), (module ...), импорты/экспорты],
  // [структурированные блоки (block/loop/if) выражаются через форму модуля/функции],
  block(breakable: false)[Повышенная человеко-читаемость за счет иной грамматики записи],
))[ Сравнение синтаксиса языков (сводная таблица) ] <syntax-compare>

В рассматриваемых языках подходы к построению стандартной библиотеки (подключению дополнительной функциональности) существенно различаются и напрямую связаны с назначением языка и моделью исполнения. Таблица @stdlib-compare описывает принципы подключения дополнительной функциональности. В Forth "стандартная библиотека" в привычном смысле отсутствует: стандарт задаёт наборы слов (word sets), а расширение функциональности выполняется подключением дополнительных наборов слов и формированием предметно-ориентированных словарей поверх минимального ядра. В Joy стандартная поставка включает набор библиотек, сгруппированных по областям (операции над агрегатами и последовательностями, численные методы и т.п.), что соответствует учебно-исследовательскому характеру языка. В Cat библиотека остаётся небольшой и ориентирована на ядро примитивов и комбинаторов, так как основной акцент сделан на типовую систему и статический анализ. В Factor есть большая развитая стандартная библиотека и богатый набор инструментов. В WebAssembly аналогично Forth стандартной библиотеки нет (что можно рассматривать как признак низкроуровневости): взаимодействие с внешним миром осуществляется через импорты, а набор доступных функций задаётся окружением исполнения, что поддерживает переносимость модулей и отделяет семантику языка от API платформы.

Можно выделить закономерность. Если язык предназначен для некоего высокороуровневого взаимодействия, то он скорее имеет библиотеку, пусть и не самую большую (Joy @joy-tut, Cat @cat-b, Factor @factor-paper). Если же речь идет про язык близкий к машине, то стандратной библиотеки у него нет, но есть иной способ подключать дополнительную функциональность (Forth @forth-standard, Wasm @wasm-spec).

#таблица(table(
  columns: (0.5fr, 2.2fr),
  table.header(
    [Язык],
    [Средства подключения дополнительной функциональности],
  ),

  [Forth],
  [Стандарт задаёт "word sets". Расширение через подключаемые наборы слов и предметно-ориентированные словари.],

  [Joy],
  [Набор библиотек по областям (агрегаты, последовательности, численные методы, матрицы) в стандартной поставке.],

  [Cat],
  [Небольшая библиотека: примитивы стека, базовые операции и комбинаторы; акцент на типизации и анализе.],

  [Factor],
  [Обширная стандартная библиотека и интегрированные инструменты разработки, ориентированные на прикладные задачи.],

  [Wasm],
  [Доступ к функциональности через импорты окружения; модель модулей.],
))[ Сравнение подходов к подключению дополнительной функциональности ] <stdlib-compare>

// TODO отсюда вычитать
В рассмотренных языках наблюдается широкий спектр подходов к типизации — от отсутствия обязательной типовой дисциплины до строгой статической валидации как части спецификации. Сравнение приведено в таблице @typing-analysis-compare. В Forth язык обычно рассматривается как "безтиповый": элементы стека представлены машинными словами фиксированной разрядности, а корректность их интерпретации обеспечивается соглашениями программиста. Joy является динамически типизированным языком: операции проверяют типы значений в момент применения, и при несоответствии ожидаемого и фактического типов возникает ошибка времени выполнения @joy-impl. Factor также динамически типизирован, однако в компиляторе реализована обязательная проверка согласованности "эффектов на стек" (stack-checker), которая статически подтверждает корректность формы и размера стека для определений @factor-paper. В Cat типизация является статической и описывает поведение слов в терминах преобразования конфигураций стека. В WebAssembly типизация является статической и нормативной: функции имеют типы параметров и результатов, инструкции типизируются через эффекты над стеком, а модуль проходит валидацию до исполнения @wasm-spec.

Анализ корректности в указанных языках реализуется различными средствами. В Forth контроль в основном возлагается на разработчика и среду исполнения.. В Joy основным механизмом остаётся динамическая проверка во время выполнения, однако используется дисциплина документирования эффектов стека, позволяющая рассматривать программу как композицию преобразований и служащая предпосылкой к статическим рассуждениям @joy-alg. В Factor статический анализ реализован через абстрактную интерпретацию эффектов слов на абстрактном стеке: анализатор проверяет согласованность высоты и структуры стека по всем ветвям управления и отклоняет некорректные определения на этапе компиляции @factor-paper. В Cat статический анализ является частью системы вывода типов: типы фиксируют форму стека до и после применения слов и комбинаторов, что обеспечивает верификацию согласованности ветвлений и инвариантов циклов @cat-a. В WebAssembly анализ представлен в форме однопроходной валидации модуля, гарантирующей корректность типов операндов и структур управления до запуска кода @wasm-spec.

#таблица(table(
  columns: (0.75fr, 1.0fr, 1.9fr),
  table.header(
    [Язык],
    [Тип типизации],
    [Используемый анализ],
  ),

  [Forth],
  [Безтиповой],
  [Проверки типовой согласованности не навязываются; корректность интерпретации содержимого стека обеспечивается соглашениями и выявляется на этапе исполнения.],

  [Joy],
  [Динамическая],
  [Динамическая проверка типов при выполнении; дисциплина "stack effects" в комментариях используется для рассуждений и частичного контроля корректности.],

  [Factor],
  [Динамическая],
  [Stack-checker как статический анализ: абстрактная интерпретация эффектов слов на абстрактном стеке и проверка согласованности ветвей; ошибки выявляются при компиляции.],

  [Cat],
  [Статическая (эффекты стека)],
  [Вывод типов и верификация формы стека, включая row-полиморфизм; гарантии согласованности ветвлений и инвариантов циклов.],

  [Wasm],
  [Статическая (нормативная)],
  [Однопроходная валидация модуля по типам и структурированному управлению; предотвращение underflow и несогласованности типов до исполнения.],
))[ Сравнение типизации и анализа ] <typing-analysis-compare>


Оптимизации в стековых языках можно условно разделить на две группы: (1) преобразования представления и диспетчеризации команд (ускоряют интерпретатор/виртуальную машину) и (2) оптимизации, использующие результаты анализа семантики (стек-эффекты, типы, структура управления), что позволяет убирать лишние проверки и преобразовывать программу без нарушения корректности.

Для Forth базовым приёмом ускорения является компиляция в нитевой код: программа представляется как последовательность ссылок на подпрограммы (слова), что уменьшает размер кода и удешевляет интерпретацию. Дополнительно важную роль играет то, что многие управляющие конструкции реализованы как слова времени компиляции и разворачиваются в более примитивные переходы и последовательности слов, что снижает накладные расходы управляющих конструкций и упрощает исполнение @forth-page.

В Joy оптимизации не являются основной целью прототипной реализации (язык в первую очередь вводится как формальная модель конкатенативного программирования) @joy-impl. Тем не менее, функциональная чистота и трактовка программы как функции вида "stack -> stack" создают удобную базу для эквивалентностных преобразований (переписывания) и специализации на уровне композиции программ, поскольку отсутствуют побочные эффекты и проще доказывать сохранение семантики @joy-math @joy-alg.

В Cat оптимизации тесно связаны со статической типизацией стека: типы фиксируют не только типы значений, но и форму стека до и после выполнения фрагмента программы. Это позволяет ещё на этапе компиляции исключать некорректные программы (underflow, несовместимость ветвей), а также использовать результаты вывода типов как формальный контракт при преобразованиях: оптимизатор может менять промежуточные представления и фрагменты кода, сохраняя наблюдаемую форму и типы стека @cat-a @cat-b.

Factor сочетает динамическую типизацию с развитой инфраструктурой статического анализа стек-эффектов. Stack-checker выполняет абстрактную интерпретацию, проверяет согласованность ветвлений и строит промежуточное представление, на котором становятся возможны агрессивные высокоуровневые оптимизации (в том числе разворачивание макросов и инлайнинг цитат), а далее — низкоуровневые оптимизации на этапе генерации машинного кода @factor-paper. На практике это снижает накладные расходы типичных для стековых языков перестановок и диспетчеризации, сохраняя при этом выразительность конкатенативного стиля.

Для Wasm ключевые оптимизационные цели заложены в самом формате: компактное бинарное представление, однопроходная валидация и предсказуемая семантика обеспечивают быстрый переход от модуля к исполнимому коду. Типизация и структурированное управление потоком позволяют рантайму быстро проверять корректность и эффективно компилировать модуль, при этом многие оптимизации выполняются либо компилятором исходного языка до генерации Wasm, либо JIT/AOT-компилятором окружения при загрузке и выполнении @wasm-spec.

Отдельный класс оптимизаций для стековых виртуальных машин — stack caching: хранение части виртуального стека (обычно верхних элементов) в регистрах реальной машины, чтобы сократить число загрузок/выгрузок и обновлений указателя стека. В работах М. А. Эрлтля предложены и подробно исследованы статический подход (компилятор отслеживает состояние кэша как автомат) и динамический подход (несколько версий интерпретатора для разных состояний кэша), а также показано, что stack caching хорошо сочетается с динамическими суперинструкциями, которые уменьшают долю времени на диспетчеризацию команд @ertl-stack-caching @ertl-diss @ertl-gregg04. Эти техники применимы не к одному конкретному языку, а к широкому классу реализаций стековых интерпретаторов и виртуальных машин, в том числе к реализациям, близким по модели исполнения к Forth, Factor и другим стековым системам.

Сводка основных техник приведена в таблице @opt-table.

#таблица(table(
  columns: (1.35fr, 2.65fr),
  table.header(
    text(size: 10pt)[Оптимизация],
    text(size: 10pt)[Краткое описание],
  ),

  text(size: 10pt)[Нитевой код (Forth)],
  text(size: 10pt)[Представление программы как последовательности ссылок на слова; снижает размер кода и удешевляет интерпретацию.],

  text(size: 10pt)[Разворачивание слов времени компиляции (Forth)],
  text(size: 10pt)[Управляющие конструкции компилируются в примитивные переходы и последовательности слов, уменьшая накладные расходы управления.],

  text(size: 10pt)[Переписывание и специализация без побочных эффектов (Joy)],
  text(size: 10pt)[Функциональная чистота упрощает эквивалентностные преобразования программ как функций "stack -> stack".],

  text(size: 10pt)[Статический вывод типов и формы стека (Cat; Wasm)],
  text(size: 10pt)[Гарантирует корректность работы со стеком и согласованность ветвей; создаёт основу для безопасных преобразований.],

  text(size: 10pt)[Проверка стек-эффектов и построение IR (Factor)],
  text(size: 10pt)[Stack-checker выполняет абстрактную интерпретацию, проверяет ветвления и формирует IR для дальнейших оптимизационных проходов.],

  text(size: 10pt)[Инлайнинг цитат и макро-расширение (Factor)],
  text(size: 10pt)[Снижение накладных расходов вызовов и диспетчеризации за счёт разворачивания и специализации на этапе компиляции.],

  text(size: 10pt)[Stack caching (интерпретаторы стековых ВМ: Forth/Factor и др.)],
  text(size: 10pt)[Кэширование верхних элементов стека в регистрах, уменьшение обращений к памяти и обновлений указателя стека; статические и динамические схемы.],

  text(size: 10pt)[Динамические суперинструкции (интерпретаторы стековых ВМ)],
  text(size: 10pt)[Объединение частых последовательностей инструкций в одну “суперинструкцию” для уменьшения диспетчеризации; хорошо сочетается со stack caching.],

  text(size: 10pt)[Быстрая валидация и JIT/AOT компиляция модулей (Wasm)],
  text(size: 10pt)[Однопроходная проверка и предсказуемая семантика позволяют быстро компилировать модуль в машинный код средствами окружения.],
))[ Сравнение основных оптимизационных техник в стековых языках ] <opt-table>


Работа с памятью в рассматриваемых языках определяется прежде всего назначением языка и типичной средой исполнения. В Forth память является частью базовой модели языка: программист напрямую работает с адресами и примитивами чтения/записи, а управление размещением данных в значительной степени задаётся соглашениями и библиотечными словами конкретной реализации, что соответствует системному и встраиваемому профилю языка @forth-standard. В Joy активное использование динамических структур данных (списки, строки, цитаты) приводит к тому, что в базовой реализации управление временем жизни объектов скрыто от программиста и обеспечивается автоматической сборкой мусора @joy-impl. В Cat модель памяти в данном контексте определяется целевой платформой (.NET CIL): для практического исполнения типично использование управляемой среды, а основной акцент языка сделан на статической верификации стековых преобразований и корректности управления потоком @cat-b. В Factor управление памятью встроено в виртуальную машину и реализовано сборщиком мусора (с разделением по поколениям), а для неуправляемых ресурсов предусмотрены отдельные средства, что соответствует ориентации языка на прикладное программирование общего назначения @factor-paper. В WebAssembly управление памятью в базовом виде остаётся низкоуровневым: доступ к памяти осуществляется через модель линейной памяти и инструкции загрузки/сохранения, а гарантии корректности работы с памятью делегируются исходному языку и его рантайму (или разработчику), поскольку Wasm является целью компиляции @wasm-spec. Сводные различия приведены в таблице @mem-compare.

#таблица(table(
  columns: (0.8fr, 2.2fr),
  table.header(
    [Язык],
    [Способ управления памятью],
  ),

  [Forth],
  [Явная работа с адресами и памятью через примитивы чтения/записи; управление размещением определяется реализацией и соглашениями.],

  [Joy],
  [Автоматическая сборка мусора в базовой реализации; управление временем жизни объектов скрыто от программиста.],

  [Cat],
  [Опора на целевую управляемую среду (.NET CIL); акцент на верификации стековых преобразований, а не на собственной модели памяти.],

  [Factor],
  [Сборщик мусора во встроенной виртуальной машине (поколения); отдельные средства для неуправляемых ресурсов.],

  [Wasm],
  [Низкоуровневая линейная память и явные load/store; гарантии корректности и управление временем жизни задаются исходным языком и его рантаймом.],
))[ Сравнение подходов к управлению памятью ] <mem-compare>

Области применения рассмотренных языков в значительной степени определяются тем, на какие ограничения и требования изначально ориентирована их модель исполнения. Forth применяется во встраиваемых и ресурсно-ограниченных системах и в системах реального времени, где наиболее характерны малый размер среды, предсказуемость поведения и возможность низкоуровневого управления аппаратурой через минимальное ядро и расширяемый словарь слов @forth-page. Joy имеет преимущественно академическое и экспериментальное применение: язык используется как формальная и наглядная модель конкатенативного функционального программирования, где ключевыми являются чистота вычислений и удобство математического описания программы как функции вида "stack -> stack" @joy-math @joy-impl. Cat также относится к исследовательским языкам, однако его практическая направленность смещена в сторону верификации и оптимизации: статическая типизация стека и вывод типов ориентированы на предотвращение ошибок и на возможность безопасных преобразований программ, в том числе в контексте .NET CIL @cat-a @cat-b. Factor занимает нишу языка общего назначения: для него наиболее характерны развитая стандартная библиотека, инструменты разработки и оптимизирующая компиляция, при этом сохранён конкатенативный стиль и используется статический контроль формы стека (stack-checker) как средство повышения надёжности и производительности @factor-paper @factor-wiki. WebAssembly является целью компиляции и используется как переносимый низкоуровневый формат для безопасного исполнения недоверенного кода, прежде всего в веб-среде; для него наиболее характерны строгая валидация, предсказуемая семантика и совместимость с различными исходными языками и рантаймами @wasm-spec.

Таким образом, по областям применения можно выделить типичные "характерные черты" стековых языков: для встраиваемых и системных задач наиболее важны минимализм и прямой контроль над ресурсами (Forth); для учебных и исследовательских задач — формальная простота модели и возможность строгих рассуждений о композиции программ (Joy); для задач верификации и статического контроля — типизация эффектов стека и вывод типов, позволяющие гарантировать корректность управления потоком и формы стека (Cat); для прикладного программирования общего назначения — сочетание богатой библиотеки и инструментария с компиляцией и анализом, уменьшающими типичные риски стековой модели (Factor); для переносимого и изолированного исполнения — стандартизованный байткод, однопроходная валидация и возможность эффективной компиляции в машинный код в рантайме (Wasm).

// == Выводы

В целом же в пути развития стековых языков видна явная тенденция: изначально работающие на высоких скоростях и низких уровнях абстракций благодаря простоте, высокой переносимости  и оптимизациям (например, нитевой код Forth), доступным фактическо бесплатно за счет структуры программ и модели исполнения, стековые языки обзаводятся мощной формальной базой, которая позволяет точно описывать работу программ и проводить мощный статический анализ. Статический анализ открывает для стековых языков новые возможности: верификация кода и агрессивные оптимизации являются несомненно большими преимуществами для низкоуровневых языков.

Одной из вершин достижений стековых языков можно считать Wasm. Исходные цели проектирования @wasm-spec диктуют идеальные для использования стекового языка условия, на основе которых выросла система, сочетающая в себе сразу несколько преимуществ, изначально считающихся несочетаемыми: отличная портируемость под разные платформы, но при этом высокая производительность (например, в сравнении с традиционными движками ECMAScript) за счет низкоуровневости и мощных оптимизаций, а также верифицируемость (и оттого частично безопаность). Wasm вбирает в себя теоретические и практические наработки в области стековых языков, решая с помощью них сложную задачу исполнения прикладного кода с учетом заданных требований.

В результате анализа можно сделать вывод, что современная ниша стековых языков -- это быстрые виртуальные машины, запускаемые на широком диапазоне устройств. Это утверждение также подтверждается фактом, что спецификации самых распространенных виртальных машин (JVM, .NET CLR, Wasm) используеют стековую модель исполнения кода. /* TODO ссылка */

// В целом, благодаря экономичности и простоте реализации (а значит, и простоте портирования на различные архитектуры) стековые языки активно применяются в низкоуровневых системах (системы реального времени, встраиваемые системах), различных низкоуровневых виртуальных машинах (WebAssembly, JVM, .NET), графических процессорах и других специализированных областях.
