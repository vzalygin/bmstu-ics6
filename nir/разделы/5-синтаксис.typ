#import "../version.typ": *

= Анализ синтаксиса

/* Тут надо в несколько абзацев рассказать, какой синтаксис используется в языках из обзора. Информацию надо подавать структурированно. Будет хорошо, если ты также будешь ссылать на различные документы через @ и название документа из файла с списком источников. Хорошо было бы найти формальные описания грамматик для таких языков */

Для большей части языков, рассмотренных в обзоре, характерен "конкатенативный" тип синтаксической организации: программа представляется линейной последовательностью лексем (или слов, комбинаторов, функций), а их конкатенация в тексте соответствует композиции набора преобразований неявного стека данных. В такой модели вызов подпрограммы, как правило, не имеет самостоятельной скобочной формы вида "f(x)", а выражается отдельным токеном. В конкатенативных языках у фукнций всегда есть один и только один неявный аргумент -- стек данных. В формальных описаниях конкатенативных языков фиксируется именно списковая структура выражений, где единицей синтаксиса выступает слово, а выражение задаётся как список слов с возможными литералами и блоками (цитатами) @stack-paper. Исключение составляют некоторые конструкции времени компиляции, которые затем преобразуются в соответствующую последовательность слов.

Грамматику синтаксиса конкатенативных языков можно описать при помощи синтаксической диаграммы на рисунке @синт-диаграмма-кон. На рисунке "термом" обозначаются те самые слова, комбинаторы, функции (конкретный термин зависит от контекста конкретного языка).

#рис(image("../материалы/курсач_трпс-1 Синтаксическая диаграмма.drawio.png"))[ Синтаксическая диаграмма аксиомы грамматики конкатенативных языков ] <синт-диаграмма-кон>

В языке Forth особоую роль играет интерактивная модель "текстового интерпретатора": входная строка разбивается на токены, которые ищутся в словаре и либо исполняются немедленно, либо компилируются в новое определение @forth-page. Базовая конструкция задания определения представляет собой так называемое "colon definition" вида ": name ... ;": слово ":" считывает имя и переводит систему в режим компиляции, а ";" завершает определение и возвращает режим интерпретации @forth-standard.

Языки семейства Joy сохраняют постфиксную запись и токенизацию по пробельным разделителям, но дополняют её явными литералами структур данных и механизмом "цитирования" программ. В Joy квадратные скобки "[...]" используются для записи списков и одновременно для представления "цитаты" как значения, которое может передаваться через стек и затем исполняться посредством комбинаторов @joy-tut. Определения новых слов задаются в форме равенств "name == ...". В языке распростренны комментарии на основе stack-effect нотации. 

Factor использует аналогичный Joy синтаксис. Важной особенностью является применение "stack effect notation": сигнатуры в скобках с разделителем "--", включаемой непосредственно в текст определения слова как его формализованного интерфейса @factor-paper, которая затем используется компилятором для статического анализа.

Для языка Cat выделяется предельно компактное синтаксическое ядро, формируемое двумя операциями: цитированием и композицией. Это ядро может быть выражено абстрактной грамматикой из листинга @cat-gram @cat-a. В прикладных описаниях Cat данная основа дополняется также набором правил, задающих определение слова (терма). В результате синтаксис Cat близок к языкам Joy-семейства по внешнему виду.

#листинг(```
axiom ::= term
term ::= [term] | term term | empty
```)[ Аксиома грамматики и правило языка Cat (правила с терминалами не показаны) ] <cat-gram>

Синтакт Wasm принциально отличается. Спецификация определяет текстовый формат, основанный на S-выражениях, в котором модуль задаётся как иерархическая скобочная структура @wasm-syntax. Вместе с тем тело функции сохраняет линейный характер и соответствует стековой виртуальной машине: инструкции потребляют и порождают значения на неявном стеке @wasm-spec. Листинг @wasm-rule приводит правила для построения грамматики.

Таким образом, синтаксис рассмотренных языков образует спектр от "операционально задаваемого" (Forth, где значимую роль играют слова-парсеры и режимы интерпретации/компиляции) до "формально фиксированного" (WebAssembly, где нормативно определена грамматика текстового формата). При этом сохраняется общий принцип: последовательность токенов интерпретируется как композиция стековых преобразований, а скобочные конструкции применяются локально -- преимущественно для представления цитат или для древовидного описания модулей @joy-tut @factor-paper @cat-a @wasm-spec.

#листинг(```
axiom ::= expr
expr ::= (expr-type opers)
opers ::= term | expr
```)[ Акиома и правила грамматики Wasm (правила с терминалами не показаны) ] <wasm-rule>
