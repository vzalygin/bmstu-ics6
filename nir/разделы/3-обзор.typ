#import "../version.typ": *

= Аналитический обзор существующих языков

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько значимых языков, каждый из которых привнес важные нововведения в области стековых языков (речь о которых пойдет далее). Для языков рассматриваются аспекты синтаксиса, типизации, работы с памятью и стандартной библиотекой, особенности каждого языка. В обзор не включены, однако также заслуживают внимания:

- конкатенативный язык программирования Kitten, который продолжает идеи языка Cat в статическом анализе и представляет способ явного указания типов;
- .NET CIL и байткод Java, которые также являются языками под стековые виртуальные машины (.NET CLR и JVM соответственно).

/*
- общий абзац про историю языка
- синтаксис
- стандартная библиотека
- система типов, статический и динамический анализ
- оптимизации
- работа с памятью
- область применения
*/

== Язык программирования Forth

Forth является одним из первых стековых конкатенативных языков программирования. Логотип языка представлен на рисунке~@forth-logo. Forth создан Чарльзом Муром в начале 1970-х годов как сочетание расширяемого языка и интерактивной методологии разработки. Основная идея состоит в минимальном ядре и словаре «слов» (подпрограмм), через которые реализуется как высокоуровневая логика, так и низкоуровневое аппаратное управление. Новые слова добавляются прямо во время работы системы, что позволяет подстраивать язык под конкретную предметную область.

#рис(image("../материалы/forth.png", width: 70%))[ Логотип Forth ] <forth-logo>

Синтаксис Forth основан на обратной польской нотации: программа представляет собой последовательность слов, разделённых пробелами. Интерпретатор последовательно читает токены, ищет их в словаре и либо выполняет связанный код, либо интерпретирует токен как число и помещает его на стек. Определения новых слов задаются конструкцией вида ": NAME ... ;", при этом большинство лексем — от переменных до управляющих конструкций — оформляются как слова. Грамматика языка показана в листинге <ebnf-forth1>.

Стандартной библиотеки в привычном понимании в Forth нет: расширение возможностей осуществляется за счёт подключения и использования дополнительных наборов слов (word sets), входящих в конкретную реализацию среды.

#листинг(```
program        ::= { item } ;
item           ::= word | number | string | comment | definition ;

definition     ::= ":" name { item } ";" ;

word           ::= name ;
name           ::= letter { letter | digit | "-" | "_" } ;

number         ::= ["+"|"-"] digit { digit } ;
string         ::= ".\"" { char - "\"" } "\"" ;
comment        ::= "(" { char - ")" } ")" | "\" " { char - EOL } ;

letter         ::= "A".."Z" | "a".."z" ;
digit          ::= "0".."9" ;
```)[ РФБН Forth ] <ebnf-forth1>

С точки зрения семантики типов Forth рассматривается как «безтиповый»~@forth-standard: данные представляются машинными словами фиксированной разрядности, а язык не навязывает проверку согласованности типов -- ответственность за корректность интерпретации содержимого стека возлагается на разработчика. Такой подход обеспечивает гибкость в описании программ и предсказуемое временное поведение (так как любая команда ), но затрудняет статический анализ и контроль.

Forth является интерактивной средой, в которой процесс исполнения программы можно разделить на 2 составляющие: состояние интерпретации и состояние компиляции. В состоянии интерпретации среда занимается исполнением примитивных слов. В то же время, если среда в процессе встречает некоторый набор слов (например, ":" -- создание нового слова), то она переходит в состояние компиляции и осуществляет разбор подпрограмм, встречаемых синтаксических конструкций. Выполнить переключение состояния также можно при помощи специальных слов "[" -- переход в состояние интерпретации и "]" -- переход в состояние компиляции. Определения новых слов задаются конструкцией вида ": NAME ... ;", причём большинство лексем -- от переменных до управляющих конструкций -- являются словами. Стандартный «core word set» ANS Forth~@forth-standard включает базовые стековые операции ("DUP", "DROP", "SWAP", "OVER"), арифметику ("+ - \* /"), сравнения, примитивы работы с памятью ("\@" -- чтение по адресу, "!" -- запись по адресу), конструкции ветвления и циклов ("IF … ELSE … THEN", "DO … LOOP"), а также определяющие слова "CREATE", "VARIABLE", "CONSTANT" и др. Остальные word set’ы стандарта являются опциональными расширениями. Почти все управляющие слова в Forth реализуются при помощи понятия слов времени компиляции, то есть конструкций, которые во время компиляции разворачиваются в более примитивные последовательности слов. Например, конструкция с ветвлением "... DUP 6 < IF DROP 5 ELSE 1 - THEN ..." разворачивается в последовательность слов "... DUP LIT 6 < ?BRANCH 5 DROP LIT 5 BRANCH 3 LIT 1 - ..." -- конструкция условного перехода заменена на слова условного и безусловного переходов~@forth-page.

В листинге~@forth-example определяется слово "HELLO", которое затем вызывается и выводит в консоль текст. Круглые кавычки используются для комментариев.

#листинг(```
: HELLO  CR ." Hello, World!" ;
HELLO ( выводит Hello, World! в консоль на следующей строке после вызова слова )
```)[ Определение и использование слова "HELLO" ] <forth-example>

Forth применяется во встраиваемых и ресурсно-ограниченных системах, прошивках, системах реального времени и космической технике. В частности, он используется в контроллерах космических аппаратов и приборов NASA, а также в реализациях Open Firmware для платформ Apple, IBM и Sun. К характерным особенностям практического использования относятся малый размер полной среды (компилятор, интерпретатор и редактор могут размещаться в памяти 8-битных систем), а также единство языка и среды исполнения: Forth одновременно выступает командной оболочкой, компилятором и минимальной операционной системой, при этом стандарт описывает набор слов и модель стека, оставляя свободу построения предметно-ориентированных расширений и диалектов~@forth-page.

== Язык программирования Joy

В 2001 году Манфред фон Тун из университета Ла Троба представил язык Joy как попытку формализации логики стековых языков. Joy представляет собой функциональный стековый конкатенативный язык программирования~@joy-tut. В отличие от традиционных функциональных языков, которые строятся вокруг операции применения функции к аргументу, Joy использует операцию композиции функций~@joy-math. Автор вводит формальную основу: каждая команда в Joy обозначает унарную функцию вида "stack -> stack": на вход подаётся состояние (стек данных), в процессе применения команды происходит его модификация и передача следующей команде; значения и подпрограммы при этом также передаются через стек.

Язык с точки зрения математики формализуется следующим образом: множество всех программ образует синтаксический моноид по операции конкатенации (ассоциативная операция «склейки» программ и пустая программа как нейтральный элемент), а множество функций "stack -> stack" -- семантический моноид по операции композиции и тождественной функции в роли нейтрального элемента~@joy-math. Отображение, которое каждой программе сопоставляет её «смысл» (как некоторую функцию над стеком), является гомоморфизмом моноидов, то есть сохраняет операцию: смысл "P Q" равен композиции смыслов "P" и "Q", а смысл пустой программы -- тождественная функция~@joy-alg. /* (Моноид здесь понимается в стандартном алгебраическом смысле: набор объектов + одна ассоциативная операция + нейтральный элемент; гомоморфизм -- отображение, которое не ломает эту структуру.)*/

Как в случае с Forth, синтаксис Joy основан на постфиксной записи~@joy-tut. Программа представляет собой последовательность слов, разделённых пробелами, исполнение происходит слева направо. Каждое слово выполняет некоторое преобразование над стеком данных. Операторы снимают одно или несколько значений с вершины стека и помещают результат обратно. Язык определяет способ записи отложенных вычислений при помощи механизма цитат, которая содержащит фрагмент программы как данные~@joy-tut. Для представления структур данных используются литералы: цитаты программ записываются в квадратных скобках "[...]", множества — в фигурных скобках, строки — в кавычках. Определения новых слов записываются в виде равенств, например "square == dup \* .". Язык при этом остаётся функционально чистым: стандартные операции не изменяют скрытое глобальное состояние, а только преобразуют стек, что позволяет рассматривать программу как математическую функцию "stack -> stack" без побочных эффектов~@joy-math. Листинг~@ebnf-joy иллюстрирует грамматику языка.

#листинг(```
program        ::= { term } ;
term           ::= word | literal | quote | set | string | definition ;

definition     ::= name "==" program "." ;

quote          ::= "[" program "]" ;
set            ::= "{" { term } "}" ;
string         ::= "\"" { char - "\"" } "\"" ;

literal        ::= number ;
word           ::= name ;
name           ::= letter { letter | digit | "_" | "-" } ;
number         ::= ["+"|"-"] digit { digit } ;
```)[ РБНФ грамматики Joy ] <ebnf-joy>

При построении идиоматических программ на Joy активно используются комбинаторы. В контексте языка это стековые функции, которые принимают одну или несколько цитат программ (списков слов) и управляют их исполнением различными способами~@joy-tut. Например, функция-комбинатор "i" ("interpret") берет вершину стека и исполняет список слов, которые лежали внутри вершины. С точки зрения синтаксиса это эквивалентно опусканию скобочек: "[ 1 print ] i" значит то же самое, что и "1 print". Для ветвлений используется комбинатор "ifte", для циклических алгоритмов -- комбинаторы различных схем рекурсии "primrec", "linrec", "binrec". Программист волен создавать и свои функции-комбинаторы на основе уже существующих через механизм определения новых слов.

Благодаря возможности определять новые слова, которые могут выступать как обычные функции или как комбинаторы, Joy располагает достаточно разветвлённой стандартной библиотекой. В стандартной поставке присутствует несколько библиотек, сгруппированных по областям применения. Так, библиотеки "agglib" и "seqlib" содержат обобщённые операции над агрегатами (неупорядоченными множествами, строками и списками) и последовательностями, "numlib" включает числовые функции и численные методы, а "mtrlib" предназначена для работы с матрицами~@joy-impl.

Joy является динамически типизированным языком. В язык встроены числовые типы (целые и вещественные числа), агрегатные типы (строки, списки и неупорядоченные множества), а также тип цитат~@joy-tut. Типизация стека на этапе компиляции не контролируется, и проверка типов выполняется в момент применения операции. При несовпадении ожидаемого и фактического типов возникает ошибка времени выполнения~@joy-impl. Для уменьшения числа подобных ошибок рекомендуется сопровождать определения функций комментариями в нотации эффектов стека, где указывается, какой стек функция принимает и какой возвращает, например "dup : A -> A A" или "+ : Int Int -> Int". Такая нотация позволяет рассматривать программы как формулы в рамках алгебры стеков и служит основой для рассуждений о корректности и эквивалентности программ~@joy-alg, что можно рассматривать как предпосылку к статическому анализу.

Работа с памятью в Joy в значительной степени скрыта от программиста. Базовая реализация языка представляет собой интерпретатор на языке C с автоматической сборкой мусора, что позволяет безопасно работать с динамическими структурами данных, такими как списки, строки и цитаты, без явного управления временем их жизни~@joy-impl.

Язык Joy имеет преимущественно академическое и экспериментальное применение, так как используется для демонстрации и исследования идей функционального программирования в стековой модели исполнения. В результате Joy можно рассматривать как компактную и хорошо формализованную модель стекового языка высокого уровня, в которой математические понятия моноида и гомоморфизма служат точным описанием связи между текстом программы и её поведением при выполнении.

== Язык программирования Cat

Логическим продолжением Joy является экспериментальный язык Cat (логотип языка показан на рисунке~@cat-logo), по которому в 2006 году Кристофером Диггинсом опубликовано несколько статей~@cat-a@cat-b. Cat наследует идею Joy: любая программа рассматривается как функция вида "stack -> stack", а основная операция — композиция таких функций, реализуемая простой конкатенацией лексем в исходном тексте программы. Cat вводит статическую систему типов поверх этой модели, что позволяет компилятору на этапе компиляции вычислить размер стека данных и его типизацию для любого момента времени исполнения программы и верифицировать программу на соответствие ожидаемым и фактическим типам~@cat-b. Таким образом, за счёт статического анализа возможно предотвратить ошибки времени выполнения, связанные с несовпадением типов, опустошением или переполнением стека; кроме того, статический анализ открывает путь к агрессивным оптимизациям, затрагивающим текст программы и промежуточные представления.

#рис(image("../материалы/cat.jpg"))[ Логотип Cat ] <cat-logo>

Аналогично Joy, программы на языке Cat опираются на обратную польскую запись с последовательным перечислением слов слева направо~@cat-b. Работа с потоком исполнения организована при помощи комбинаторов "if" и "while", соответствующих ветвлению и циклу по условию: комбинаторы принимают набор цитат (которые, аналогично Joy, записываются в квадратных скобках; также цитаты называют замыканиями) и организуют поток управления. Определение новых слов возможно при помощи слова "define", определения являются глобальными и единственными (множественные определения запрещены). РФБН грамматики синтаксиса Cat показана в листинге~@ebnf-cat.

Стандартная библиотека Cat небольшая. В множестве команд языка доступны арифметические и логические операции, операции сравнения, операции манипуляции стеком и комбинаторы (или, как привычнее для Cat, функции высшего порядка). Также существуют примитивы для работы с последовательностями и рекурсивными алгоритмами.

#листинг(```
program        ::= { term } ;
term           ::= word | literal | quote | definition ;

definition     ::= "define" name program ";" ;    (* глобальное и единственное определение *)
quote          ::= "[" program "]" ;              (* цитата/замыкание *)

literal        ::= number ;
word           ::= name ;
name           ::= letter { letter | digit | "_" | "-" } ;
number         ::= ["+"|"-"] digit { digit } ;
```)[ РБНФ грамматики Cat ] <ebnf-cat>

Наибольшего внимания заслуживает система типов Cat, благодаря которой строится статический анализ. Система типов описывает поведение функций в терминах потребления и производства элементов стека. Тип функции определяется тем, что функция ожидает на стеке перед началом выполнения, и тем, что она оставляет на стеке после выполнения. Тип записывается как круглые скобки с стрелкой внутри между конфигурациями стека~@cat-a, например "(int int -> int)" для операции сложения или "(\'S \'a  -> \'S \'a \'a)" для дублирования вершины стека. Типы с апострофом ("'\a", "\'b") обозначают типовые переменные, а специальные "типовые векторы", обозначаемые заглавными буквами ("\'A", "\'B"), представляют произвольные последовательности типов, то есть "хвост" стека. Такое представление соответствует row-полиморфизму: каждая функция не только определяет, какие значения она снимает и кладёт на вершину стека, но и неявно пропускает через себя остальную часть стека, обозначаемую элементов типового вектора; это позволяет типизировать локальные преобразования независимо от длины и состава хвоста стека. Диггинс разделяет хвост (типовой вектор) и голову (типовые переменные) стека через различие между "родами" (kinds) для обычных типов и для стеков значений: типы значений и типы стеков образуют две категории, для которых определяются функции "stack -> stack", а типизация выражается в виде правил натурального вывода. Вывод типов в Cat базируется на вариации алгоритма Хиндли–Милнера, обобщённой на стековые типы и row-полиморфизм. В статье~@cat-b описывается пример вывода типов композиции нескольких комбинаторов (которая сама также является комбинатором). Конструкции языка допускают полиморфизм более высоких рангов (в контексте Cat это означает, что позволяется выводить типы для функций, которые манипулируют другими полиморфными функциями сколь угодной степени вложенности), а аннотации типов ("stack diagrams") используются как документация и как данные для статического анализа. В статье~@cat-b описывается чистое подмножество языка Cat с правилами вывода, показанными в листинге~@cat-rules: алгоритм проходит по словам, находит тип каждой композиции, после чего выполняет унификацию типов согласно алгоритму Хиндли–Милнера.

#листинг(```
pop : ('a -> )
dup : ('a -> 'a 'a)
swap: ('a 'b -> 'b 'a)
if  : ('A bool ('A -> 'B) ('A -> 'B) -> 'B)
eval: ('A ('A -> 'B) -> 'B)
while:('A ('A -> 'A) ('A -> 'A bool) -> 'A)
```)[ Правила вывода основных слов в Cat ] <cat-rules>

Статический анализ в Cat не ограничивается проверкой согласованности типов. Поскольку тип функции фиксирует не только типы элементов, но и форму стека до и после применения функции, система гарантирует отсутствие недопустимых ситуаций, таких как недостаток аргументов на стеке или несовместимость конфигураций стека в ветвлениях~@cat-a. Для условного оператора "if" тип требует, чтобы обе ветви, принимая на вход одну и ту же конфигурацию стека, возвращали стек одинаковой структуры; в противном случае выражение считается некорректным. Для цикла "while" тип требует, чтобы после выполнения цикла конфигурация стека оставалась такой же, как и на момент начала цикла (как это и показано в листинге~@cat-rules). Дополнительно вводится различие между чистыми и побочными функциями при помощи двух видов стрелок (-> и \~>): функция считается имеющей побочный эффект, если в её реализации используется хотя бы одна побочная операция (такая операция, которая меняет не только переданные данные, то есть стек данных, но и окружение; например, операция ввода или вывода). Эта информация фиксируется в типах и может использоваться оптимизатором и верификатором~@cat-a.

Статический анализ открывает путь к агрессивным оптимизациям, которые могут изменять текст программы и промежуточные представления для повышения производительности. Поскольку типы фиксируют форму и размер стека, оптимизатор может опираться на результаты вывода типов как на формализованный контракт корректности~@cat-b@cat-a: форма и размер стека должны остаться прежними после оптимизаций с точки зрения глобального наблюдателя.

Область применения Cat складывается из двух направлений. Во-первых, язык используется как исследовательская и учебная платформа для изучения конкатенативного программирования, типовых систем с выводом типов и row-полиморфизма в стековой модели; работы по типизации функциональных стековых языков опираются на Cat и рассматривают его как пример статически типизированного конкатенативного языка. Во-вторых, Cat разрабатывается как промежуточный язык для компиляторов и инструментов анализа, также используется для верификации и оптимизации программ под платформу .NET CIL~@cat-b. Язык повлиял на дальнейшие разработки в области конкатенативных языков и типовых систем. В итоге Cat формирует пример полноценно типизированного стекового языка, в котором идея "программа как функция stack -> stack, конкатенация как композиция" соединяется с сильной статической системой типов, ориентированной на анализ и оптимизацию, что дает хорошие возможности для развития новых прикладных решений.

== Язык программирования Factor

Среди стековых языков Factor занимает нишу языков общего назначения~@factor-paper. Первая версия языка была выпущена в 2003 году Славой Пестовым. Логотип языка показан на рисунке~@factor-logo. Factor заимствует многие элементы из языка Joy: конкатенативный синтаксис, использование комбинаторов для управления потоком исполнения, а также аналогичный способ создания собственных комбинаторов при помощи цитат.

#рис(image("../материалы/factor.png"))[ Логотип Factor ] <factor-logo>

Синтаксис Factor является конкатенативным: программа записывается как последовательность слов, применяемых слева направо, а для управления потоком исполнения используются комбинаторы и цитаты. Пример определения нового слова приведён в листинге~@factor-example; в нём показано использование нотации "stack effects", а также комбинатора "if" и цитат. В определении грамматики видно в листинге~@ebnf-factor, что описание stack effect встроено в синтаксис.

#листинг(```
: factorial ( n -- n! )
dup 0 =
[ drop 1 ]
[ dup 1 - factorial * ]
if ;
```)[ Определение слова вычисления факториала ] <factor-example>

#листинг(```
program        ::= { term } ;
term           ::= word | literal | quotation | definition ;

definition     ::= ":" name [ stack_effect ] program ";" ;
stack_effect   ::= "(" { token } "--" { token } ")" ;

quotation      ::= "[" program "]" ;
literal        ::= number | string ;
string         ::= "\"" { char - "\"" } "\"" ;

word           ::= name ;
name           ::= letter { letter | digit | "_" | "-" } ;
number         ::= ["+"|"-"] digit { digit } ;
```)[ РБНФ Factor ] <ebnf-factor>

Прикладным язык считается за счёт большой стандартной библиотеки, которая позволяет решать широкий спектр прикладных задач. В отличие от Joy, стандартная библиотека Factor обладает существенно большими размерами и количеством возможностей. Например, в рамках стандартной библиотеки поставляется веб-фреймворк, XML-парсер, компоненты для построения приложений с графическим интерфейсом. Также для языка существует большое количество различных инструментов разработки, объединённых в IDE: интерактивный отладчик, браузер документации, инспектор объектов, механизм модификации программы без её перезапуска~@factor-wiki.

Как и Joy, Factor является динамически типизированным языком~@factor-paper. Документация и сообщество активно используют нотацию "stack effects", с помощью которой описывается, как то или иное слово при применении модифицирует стек. Оптимизирующий компилятор может проверить объявленные эффекты и отклоняет определения, для которых эффект не удаётся вывести, трактуя это как ошибку компиляции. Внутренний механизм этой проверки описывается как абстрактная интерпретация программы: stack-checker симулирует эффекты слов на абстрактном стеке, при встрече ветвлений анализирует обе ветви и унифицирует состояния, а несовместимость высоты или формы стека превращается в ошибку времени компиляции. Такая "проверка стека" играет роль статического анализатора, который обнаруживает классы ошибок, типичные для стековых языков, и одновременно создаёт основу для агрессивных оптимизаций~@factor-paper. Прикладным язык считается также за счёт статического анализа (stack-checker) и динамических проверок времени исполнения, которые обеспечивают верификацию программ и повышают применимость языка для продуктовых задач.

В целом язык предлагает множество высокоуровневых и низкоуровневых оптимизаций. Оптимизирующий компилятор состоит из фронтенда, который строит промежуточное представление языка, используемое для работы stack-checker и высокоуровневых оптимизаций, а также бекенда, который генерирует исполняемый машинный код и выполняет низкоуровневые оптимизации~@factor-paper.

Для работы с памятью язык использует сборщик мусора, встроенный в виртуальную стековую машину. Для молодых объектов применяется копирующий сборщик, для старшего поколения используется алгоритм "mark-sweep-compact"~@factor-paper. Для работы с неуправляемыми ресурсами используются библиотека "destructors" и комбинатор "with-destructors". Использование умного сборщика мусора также повышает степень пригодности языка к решению задач широкого спектра.

Язык Factor относится к языкам общего назначения и ориентирован на решение прикладных задач за счёт обширной стандартной библиотеки, развитого инструментария и оптимизирующей компиляции~@factor-paper@factor-wiki.

== Язык программирования Wasm

В 2017 году группа компаний, в которую входят W3C, Mozilla, Google, Microsoft и Apple, представила язык WebAssembly (Wasm). Логотип Wasm показан на рисунке~@wasm-logo. Wasm представляет собой низкоуровневый переносимый байткод и архитектуру набора команд под виртуальную стековую машину, запускаемую преимущественно (но не только) в веб-браузерах наравне с движками ECMAScript для исполнения клиентского кода~@wasm-spec. Это первый из представленных в обзоре языков, который является целью компиляции, а не сам компилируется во что-либо. Поддержка компиляции в Wasm имеется для множества высокоуровневых языков, в первую очередь для C/C++/Rust, которые имеют небольшой (или вовсе не имеют) рантайм. Особенность области использования wasm -- веб-браузер не может считать никакой получаеммый код доверенным, в результате чего к языку и машине Wasm предъявляются парадоксальные требования: виртуальная машина wasm должна дополнительно верифицировать код, порожденный тем или иным компилятором, за минимальное время с целью скорейшего непосредственного запуска программы. Хотя для других описанный в обзоре языков такая проверка была уместна, так как тексты программ пишутся человеком, которому свойственно ошибаться, для Wasm подобная проверка остается также уместной. Таким образом, в исходных целях проектирования Wasm фиксируются требования к компактности двоичного представления, быстрой однопроходной валидации и компиляции, а также к "песочнице" с предсказуемой семантикой, пригодной для запуска недоверенного кода~@wasm-spec.

Байткод Wasm в основном поставляется в виде бинарного представления, которое при необходимости может быть транслировано в текстовое человекочитаемое представление. Текстовый вариант основан на записи S-выражений~@wasm-syntax и называется WAT. Листинг~@wasm-example демонстрирует определение функции сложения числа с самим собой в человеко-читаемом виде.

#рис(image("../материалы/wasm.png", height: 15%))[ Логотип Wasm ] <wasm-logo>

#листинг(```
(func (param $p i32)
  (result i32)
  local.get $p
  local.get $p
  i32.add
)
```)[ Определение функции сложения числа с самим собой ] <wasm-example>

Поскольку язык является низкоуровневым, понятие стандартной библиотеки к нему не применяется. Вместо встроенных API используется модель импортов: окружение предоставляет функции и объекты, а модуль (единица трансляции Wasm) экспортирует точки входа.

Как стековый язык исполнения Wasm опирается на неявный операндный стек и структурированное управление потоком~@wasm-spec. Инструкции потребляют значения с вершины стека и помещают результаты обратно, при этом реализация не обязана хранить "настоящий" стек: спецификация описывает интерпретацию стека как набора анонимных регистров, а статическая типовая проверка делает высоту стека известной на этапах валидации и компиляции. Типизация в Wasm является статической и рассчитана на проверку до исполнения: функции имеют явные типы параметров и результатов, инструкции типизируются через эффекты над стеком, а модуль проходит валидацию, гарантирующую корректность применения инструкций к операндам нужных типов и отсутствие underflow-ошибок. Верификация модуля выполняется за один проход, что соответствует целям языка по скорости исполнения~@wasm-spec. Управление потоком задаётся структурными конструкциями (block, loop, if) и переходами к меткам (br, br_if, br_table).

В качестве оптимизационных целей Wasm фиксируются компактность двоичного представления и быстрая однопроходная валидация и компиляция~@wasm-spec. Низкоуровневый стековый байткод занимает меньше пространства и может исполняться с меньшими накладными расходами по сравнению с традиционным для браузеров кодом на ECMAScript, поскольку исполняется в специализированной виртуальной машине и компилируется в машинный код средствами рантайма.

Управление памятью осуществляется в ручном режиме: так как Wasm является целью компиляции, ответственность за гарантии при работе с памятью ложится на средства исходного языка~@wasm-spec (например, статические проверки Rust, сборщики мусора, либо, в случае C/C++, на разработчика программного обеспечения).

Язык и виртуальная машина используются в качестве безопасной "песочницы" с производительностью низкоуровневого кода, в основном исполняемой в веб-браузерах. По сравнению с ECMAScript, байткод Wasm обычно требует меньших накладных расходов при выполнении (в частности, по сравнению с исполнением через движки ECMAScript, например V8), что делает его удобной целью компиляции для переносимых модулей клиентского кода.

/*== Выводы

Вышеописанные обзоры языков позволяют проследить эволюцию стековых языков. Начавшись с близкого к аппаратной части Forth, они и заложенные в них идеи развились и со временем нашли применение в самых разных системах: от встраиваемого ПО до современных виртуальных машин и форматов переносимого кода. Основными свойстваим стековых языков счиаются простота реализации и переносимости, возможность строгой верификации корректности программ, а также минимальные накладные расходы рантайма.

Рассмотренные языки со временем приобретают большие возможности статического анализа, что открывает дополнительные возможности верификации и оптимизации программ. Благодаря этому стековые языки становятся быстрее и безопаснее для использования, что вместе с изначально им присущей высокой переносимостью и простой реализации стековой машины, дает большие преимущества в развитии как низкоуровневых языков для различного рода машин.

Таблица~@обзор собирает структурирует информацию об вышеописанных языках.

#таблица(table(
  // columns: (.7fr, 1fr, 1.2fr, 1.75fr, 1.3fr, 1.3fr),
  columns: (1fr, 2fr, 2fr, 3fr),
  // columns: (auto, auto,auto,auto,auto,auto),
  table.header(
  [Язык],
  [Год выпуска первой версии],
  // [Типизация],
  // [Анализ и оптимизации],
  // [Стандартная библиотека],
  [Область применения],
  [Вклад в развитие],
  ),
  [Forth],
  [1970],
  // [Постфиксный конкатенативный],
  // [Безтиповой],
  // [Наличие базовых оптимизаций (нитевой код), статического анализа нет],
  // [Наборы слов (ANS core + расширения)],
  [Встроенные системы],
  [Первый стековый язык],

  [Joy],
  [2001],
  // [Постфиксный конкатенативный],
  // [Динамическая типизациция],
  // [Задана формальная модель языка],
  // [Базовые слова + библиотеки слов],
  [Экспериментальный язык],
  [Внес формальное описание стековых языков],

  [Factor],
  [2003],
  // [Постфиксный конкатенативный],
  // [Динамическая типизация],
  // [Есть stack-checker и агрессивные оптимизации],
  // [Обширная стандратная библиотека и инструментарий разработки],
  [Язык общего назначения],
  [Развил методы статического и динамического анализа, оптимизаций],

  [Cat],
  [2006],
  // [Постфиксный конкатенативный],
  // [Статическая типизация стека по форме и размеру],
  // [Статический вывод типов и эффектов стека, верификация программ],
  // [Минимальная стандратная библиотека],
  [Эксперементальный язык, верификация программ .NET CIL],
  [Описал способ формальной верификации стевых программ, а также вывод типов],

  [Wasm],
  [2017],
  // [S-выражения],
  // [Статическая типизация],
  // [Статический анализ за один проход, верификация, JIT/AOT оптимизации в рантайме],
  // [Нет, но есть импортируемые API],
  [Цель компиляции для Web-среды и изолированных рантаймов],
  [],
))[ Сводная характеристика рассмотренных стековых языков ] <обзор>
*/