#import "../version.typ": *

= Анализ семантики

Семантика стековых языков удобно описывается через состояние вычислений. В простейшем случае это "операндный стек", а также (в зависимости от языка) память, словарь определений, ввод-вывод и другие компоненты среды. Выполнение программы сводится к последовательному применению слов (инструкций), каждое из которых берёт данные со стека и кладёт результаты обратно. Для языков семейства Joy/Cat/Factor распространена интерпретация "программа есть функция вида stack -> stack", а конкатенация фрагментов программы соответствует последовательному применению этих преобразований @joy-math @joy-alg.

== Типизация

Forth не задаёт строгой типовой дисциплины: элементы стека являются машинными словами, а их смысл (число, адрес, флаг) определяется соглашениями программиста. Стандарт описывает набор слов и модель стека, но не вводит обязательной проверки типов @forth-standard. На практике это повышает гибкость и предсказуемость исполнения, но осложняет контроль корректности.

Joy относится к динамически типизированным языкам: тип значения проверяется в момент применения операции. Если операция ожидает, например, число, а на стеке находится список, возникает ошибка времени выполнения @joy-impl. Для снижения числа таких ошибок часто используют "stack effect" как комментарий к определениям, фиксируя, что слово ожидает и что возвращает.

Factor также динамически типизирован, однако дополняет это обязательной проверкой "формы стека" при компиляции. Для слов обычно задаётся эффект на стек, и компилятор проверяет, что тело определения действительно согласовано по высоте и структуре стека во всех ветвлениях. Таким образом, часть типовых ошибок устраняется ещё до запуска программы @factor-paper.

Cat вводит статическую типизацию поверх стековой модели. Тип задаётся как преобразование конфигурации стека в другую конфигурацию, включая "хвост" стека через типовые переменные (row-полиморфизм). Это позволяет типизировать композиции слов и проверять корректность ветвлений и циклов на уровне типов @cat-a @cat-b.

WebAssembly изначально строится как формат с нормативной статической типизацией и валидацией: у функций есть типы параметров и результатов, а инструкции имеют определённые эффекты над стеком. Модуль перед исполнением проходит валидацию, которая гарантирует согласованность типов и отсутствие ошибок вида "недостаточно операндов на стеке" @wasm-spec.

== Статический и динамический анализ

Динамический контроль в стековых языках проявляется как проверки во время выполнения: операции снимают значения со стека и либо корректно работают, либо завершаются ошибкой (Joy), либо могут привести к некорректной интерпретации данных при отсутствии проверок (типичный сценарий для Forth) @joy-impl @forth-standard.

Статический анализ использует информацию о том, как слова изменяют стек, и пытается проверить программу до исполнения. В Factor это реализовано как "проверка стека": анализатор проходит по коду, моделирует изменения абстрактного стека и требует, чтобы в точках слияния потока управления состояние стека было совместимо. Несовместимость превращается в ошибку компиляции @factor-paper.

В Cat статический анализ встроен в систему вывода типов. Поскольку тип слова фиксирует входную и выходную конфигурации стека, система может гарантировать корректность композиции и ограничения для управляющих комбинаторов: у "if" обе ветви должны возвращать одинаковую структуру стека, у "while" конфигурация стека сохраняется как инвариант цикла @cat-a.

В WebAssembly статический анализ выражен в процедуре валидации: она проверяет типы и структуру управления (block/loop/if) и тем самым обеспечивает безопасную основу для дальнейшей компиляции и оптимизаций в рантайме @wasm-spec.

== Оптимизации

Оптимизации в стековых системах обычно направлены на две основные проблемы: накладные расходы диспетчеризации (переходы между инструкциями интерпретатора) и накладные расходы доступа к стеку (загрузки/сохранения значений в памяти).

Для Forth характерны компактные представления программы и быстрый вызов "слов". Широко используется нитевой код, где программа хранится как последовательность ссылок на подпрограммы, что ускоряет интерпретацию и снижает размер представления @forth-page. Кроме того, управляющие конструкции часто разворачиваются на этапе компиляции в более примитивные переходы, уменьшая стоимость интерпретации.

Для виртуальных стековых машин существенный вклад в оптимизацию внёс подход "кэширования стека" (stack caching). Его идея проста: держать верхние элементы операндного стека не в памяти, а в регистрах реальной машины, чтобы сократить число загрузок и выгрузок. В работах М. А. Эрткля систематизированы модели "одно- и многосостояльного" стек-кэша и рассмотрены как динамический, так и статический варианты отслеживания состояния кэша /*@ertl-1996*/. В статье "Stack Caching for Interpreters" показано, что интерпретатор может тратить значительную долю времени именно на обмен между стеком в памяти и регистрами, и предложены две техники: динамическое кэширование (несколько специализированных версий интерпретатора для разных состояний кэша) и статическое кэширование (компилятор отслеживает состояние кэша как конечный автомат и выбирает нужные варианты примитивов) /*@ertl-1995*/.

Отдельное направление оптимизаций — "суперинструкции", когда часто встречающиеся последовательности байткод-инструкций объединяются в одну более крупную операцию, уменьшая число шагов диспетчеризации. Работа "Combining Stack Caching with Dynamic Superinstructions" показывает, что совмещение суперинструкций с кэшированием стека даёт больший выигрыш, чем каждое из решений по отдельности: суперинструкции уменьшают стоимость диспетчеризации, а stack caching — стоимость стек-доступов /*@ertl-gregg-2004*/.

Factor использует собственный оптимизирующий компилятор и промежуточные представления. Наличие stack-checker даёт надёжную информацию о структуре стека, что помогает оптимизатору безопасно переписывать код, устранять лишние операции со стеком и затем генерировать эффективный машинный код @factor-paper.

Cat интересен тем, что статическая типизация "эффектов на стек" делает возможными агрессивные преобразования при сохранении корректности: типы фактически выступают контрактом, который должен сохраниться после оптимизаций. Это полезно как для верификации, так и для применения языка в роли промежуточного представления @cat-b.

В WebAssembly оптимизации в значительной степени выполняются в рантаймах (JIT/AOT). При этом стековая форма байткода удобна для компактности и быстрой валидации, а во время компиляции обычно преобразуется в более подходящее для машинного кода представление (например, регистровое) @wasm-spec.

== Управление памятью

В Forth работа с памятью является частью базовой модели: стандартные слова позволяют читать и записывать по адресу, а выделение и освобождение памяти реализуются либо явно, либо через библиотечные соглашения и слова конкретной системы @forth-standard.

В Joy активно используются динамические структуры данных (списки, строки, цитаты), поэтому реализация обычно опирается на сборку мусора, снимая с программиста необходимость вручную освобождать временные объекты @joy-impl.

В Factor управление памятью встроено в виртуальную машину и реализовано сборщиком мусора с разделением по поколениям; для неуправляемых ресурсов предусмотрены специальные библиотечные средства, позволяющие корректно освобождать внешние ресурсы @factor-paper.

В Cat модель памяти зависит от целевого окружения. В вариантах, ориентированных на .NET, управление памятью, как правило, делегируется среде выполнения, а ключевой вклад Cat связан именно с проверкой корректности стековых преобразований @cat-b.

В WebAssembly память задана как линейный массив байт, доступный через инструкции загрузки и сохранения. В базовой спецификации управление временем жизни объектов не стандартизовано: оно определяется исходным языком и его рантаймом либо предоставляется окружением через импорты @wasm-spec.

== Стандартная библиотека

Forth опирается на стандартные наборы слов ("core" и опциональные расширения), а дальнейшее расширение обычно идёт через подключаемые словари и создание предметно-ориентированных надстроек @forth-standard.

Joy поставляется с набором библиотек по областям (операции над агрегатами и последовательностями, численные функции и т.п.), однако экосистема остаётся сравнительно компактной, что соответствует учебно-исследовательскому характеру языка @joy-impl.

Factor включает обширную стандартную библиотеку и развитые средства разработки (интерактивная среда, отладка, инспекция объектов и т.д.), что делает его пригодным для прикладного использования как языка общего назначения @factor-paper @factor-wiki.

Cat ориентирован на минимальное ядро и исследовательские задачи; основной упор делается на примитивы, комбинаторы и систему типов, поэтому стандартная библиотека по объёму ограничена @cat-a.

WebAssembly не имеет "стандартной библиотеки" в традиционном смысле: модуль взаимодействует с внешним миром через импорты, а набор доступных функций определяется окружением исполнения (например, браузером или WASI) @wasm-spec.

== Выводы

Сравнение семантических аспектов показывает общий тренд: по мере развития стековых языков возрастает доля информации, доступной до исполнения (эффекты на стек, правила для ветвлений и циклов, валидация модулей). Это повышает надёжность и упрощает автоматическую проверку корректности. Одновременно исследования по реализации стековых машин на регистровых архитектурах демонстрируют, что стековая модель может быть эффективной: кэширование стека и суперинструкции позволяют существенно сократить накладные расходы интерпретации без изменения внешней семантики программ /*@ertl-1996 @ertl-1995 @ertl-gregg-2004*/.
