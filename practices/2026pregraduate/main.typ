#import "version.typ": *

#show: гост732-2017

#metadata(true) <gost732-2017-feature-table-head-small-spacing>

#let c(content) = {
  text(size: 12pt, hyphenate: false)[#block(breakable: false)[#content]]
}

#содержание()

= Введение

Целью преддипломной практики является проведения ряда аналитических работа применительно к теме ВКРБ "компилятор стекового языка программирования". В процессе работы выполняются аналитический обзор существующих стековых языков программирования, сравнительный анализ стековых языков, анализ средств вывода типов стековых языков программирования, анализ устройства байткода и модели исполнения WebAssembly.

= Аналитический обзор существующих стековых языков программирования

Начиная с семидесятых годов прошлого века было создано достаточно большое количество стековых языков. Далее рассмотрены несколько значимых языков, каждый из которых привнес важные нововведения в области стековых языков (речь о которых пойдет далее). Для языков рассматриваются аспекты синтаксиса, типизации, работы с памятью и стандартной библиотекой, особенности каждого языка. В обзор не включены, однако также заслуживают внимания:

- конкатенативный язык программирования Kitten, который продолжает идеи языка Cat в статическом анализе и представляет способ явного указания типов;
- .NET CIL и байткод Java, которые также являются языками под стековые виртуальные машины (.NET CLR и JVM соответственно).

/*
- общий абзац про историю языка
- синтаксис
- стандартная библиотека
- система типов, статический и динамический анализ
- оптимизации
- работа с памятью
- область применения
*/

Forth~-- первый известный ранний стековых конкатенативных языков, созданный Чарльзом Муром в начале 1970-х как расширяемый язык, для которого ключевые слова можно добавлять прямо во время работы системы, и таким образом сформировать собственное подмножество языка под конкретную предметную область. Синтаксис основан на обратной польской нотации или постфиксной нотации: программа~-- это последовательность слов, разделённых пробелами. Интерпретатор идет слева направо по программе и ищет лексемы в словаре доступных слов и либо выполняет их, либо трактует как число и кладёт на стек. Язык и среда исполнения едины: система работает в режимах интерпретации и компиляции, переключаясь между ними. Для добавления нового слова или отложенных вычислений используется режим компиляции, для исполнения~-- режим интерпретации. Стандартной библиотеки в привычном смысле нет~-- функциональность наращивается подключаемыми наборами слов (word sets), зависящими от конкретной реализации; при этом ANS Forth (стандарт языка) задаёт базовый набор слов "core word set" со стековыми операциями, арифметикой, сравнениями, управлением потоком и примитивами памяти. Система типов у Forth фактически "бестиповая": данные представлены машинными словами фиксированной разрядности, а корректность трактовки содержимого стека контролирует программист, что повышает гибкость и предсказуемость времени выполнения, но усложняет статический анализ и проверку ошибок. Для Forth предложена оптимизация занимаемого программой пространства техникой "нитевого кода": программа по сути является последовательностью безусловных переходов, каждый из которых ведет на инструкции, выполняющие ту или иную команду. Работа с памятью осуществляется через явные операции чтения и записи по адресу, что дает низкоуровневое управление. Область применения Forth~-- прошивки, встроенные и ресурсно-ограниченные системы, системы реального времени и космическая техника.

На основе идей Forth в 2001 году Манфред фон Тун представил язык Joy как попытку формализации логики стековых языков: каждая команда в Joy обозначает унарную функцию вида "stack -> stack": на вход подаётся стек данных (состояние программы), в процессе применения команды происходит его модификация и передача следующей команде, значения и подпрограммы при этом также передаются через стек. Программу на Joy можно рассматривать как математическую функцию "stack -> stack" без побочных эффектов~@joy-math. Язык является динамически типизированным, за проверку типов несет ответственность программист, однако ему в этом могут помогать типы, описанные явно при объявлениях функций. Синтаксис Joy также основан на постфиксной записи~@joy-tut. Фон Тун вводит идею комбинаторов~-- функций высшего порядка, которые принимают другие функции (в терминах стековых языков их принято называть цитатами) и образуют некий алгоритм обработки данных (например, комбинатор линейной рекурсии "primrec" принимает цитату тела рекурсии и цитату условия рекурсии). В стандартной поставке присутствует несколько библиотек, сгруппированных по областям применения: библиотеки "agglib" и "seqlib" содержат обобщённые операции над агрегатами (неупорядоченными множествами, строками и списками) и последовательностями, "numlib" включает числовые функции и численные методы, а "mtrlib" предназначена для работы с матрицами~@joy-impl.

В 2006 году Кристофер Диггинс опубликовал несколько технических отчетов, в рамках которых описывает алгоритм статической типизации для стековых языков, в качестве примера используя свой экспериментальный языка Cat. Cat наследует идею Joy: любая программа рассматривается как преобразование вида "stack -> stack", а основная операция~-- композиция таких преобразований, реализуемая простой конкатенацией лексем в исходном тексте программы. В плане синтаксиса Cat аналогичен предыдущим и использует обратную польскую запись. Грамматика показана на листинге~@ebnf-cat.

#листинг(```
program        ::= { term } ;
term           ::= word | literal | quote | definition ;

definition     ::= "define" name program ";" ;    (* глобальное и единственное определение *)
quote          ::= "[" program "]" ;              (* цитата/замыкание *)

literal        ::= number ;
word           ::= name ;
name           ::= letter { letter | digit | "_" | "-" } ;
number         ::= ["+"|"-"] digit { digit } ;
```)[ РБНФ грамматики Cat ] <ebnf-cat>

Статическая типизация в контексте стековых языков подразумевает, что в момент компиляции возможно построить конфигурацию стека (его размер и "форма"~-- типы значений, которые на нем лежат) для произвольного момента времени исполнения. Таким образом вывод типов открывает путь к статическому анализу и проведению оптимизаций. Подробности статического вывода типов описываются в разделе~@заголовок-вывод-типов. В языке присутствует несколько встроенных команд, их описание приведено в таблице~@команды-cat. Помимо них в язык встроены арифметические, логические, команды и команды сравнения чисел. Язык использует три типа данных~-- числа, булевы значения и цитаты.

#таблица(table(
  columns: (auto, auto),
  table.header(c[Команда], c[Описание]),
  c[apply], c[Применить цитату с вершины стека к остальному стеку.],
  c[quote], c[Захватить вершину стека в цитату.],
  c[compose], c[Выполнить композицию двух цитат и положить на стек цитату-результат композиции.],
  c[dup], c[Положить на стек дубль вершины стека.],
  c[pop], c[Удалить значение с вершины стека.],
  c[swap], c[Поменять значение на вершине стека с значением под ним.],
  c[cond], c[Комбинатор ветвления, выбирает элемент на стеке или элемент под ним в зависимости от условия.],
  c[while], c[Комбинатор для цикла "пока".],
))[ Встроенные команды Cat ] <команды-cat>

Еще одним ответвлением от Joy стал язык Factor, впервые опубликованный в 2003 году Славой Пестовым. Преемственность Factor прослеживает по нескольким деталям: синтаксис на основе обратной польской записи, аналогичная идея использования и способ создания новых комбинаторов. Ключевая особенность~-- это первый прикладной высокоуровневый стековый язык общего назначения. Так его можно назвать благодаря богатой стандартной библиотеке (такая включает в себя, например, веб-фреймворк и парсер XML) и инструментарию разработки, собранном в одной IDE и включающим в себя компилятор с развитой системой анализов, интерактивный отладчик, браузер документации, инспектор объектов. Как и Joy, язык динамический, однако существует важное отличие: при объявлении новой функции программист должен указать ее тип функции, в свою очередь компилятор проверяет этот тип на соответствие содержимому функции. Внутренний механизм этой проверки описывается как абстрактная интерпретация программы: компилятор (а точнее, модуль "Stack-checker" внутри него) симулирует эффекты команды на абстрактном стеке, при встрече ветвлений анализирует обе ветви и унифицирует состояния, а несовместимость размера или формы стека превращает в ошибку времени компиляции. На основе анализа типов компилятор проводит высокоуровневые и низкоуровневые оптимизации. Также дополнительно используются динамические проверки времени исполнения. Все эти особенности помогаю языку Factor быть вполне применимым для решения задач прикладного программирования.

Наконец стоит рассмотреть спецификацию для одноименных стекового языка и виртуальной машины WebAssembly (сокращенно Wasm), которые были разработаны и выпущены в 2017 году группой компаний, в которую входят W3C, Mozilla, Google, Microsoft и Apple. Wasm определяет низкоуровневый переносимый байткод и архитектуру и семантику набора команд под виртуальную стековую машину, запускаемую преимущественно (но не только) в веб-браузерах наравне с движками ECMAScript. В исходных целях проектирования Wasm фиксируются требования к компактности двоичного представления, быстрой однопроходной валидации и компиляции, а также к "песочнице", пригодной для запуска недоверенного кода с производительностью низкоуровневого кода.  Как стековый язык Wasm использует неявный стек данных: инструкции потребляют значения с вершины стека и помещают результаты обратно, при этом реализация не обязана хранить "настоящий" стек~-- спецификация описывает интерпретацию стека как набора анонимных регистров. Это первый из представленных в обзоре языков, который является целью компиляции, а не сам компилируется во что-либо. Поддержка компиляции в Wasm имеется для множества высокоуровневых языков, в первую очередь для полностью компилируемых языков C/C++/Rust. Для языка существует два представления: текстовое (формат "Wat" с синтаксисом на S-выражениях), удобное для чтения человеком, и бинарное, понимаемое виртуальной машиной.

= Сравнительный анализ стековых языков программирования

== Сравнение подходов к построению синтаксиса

Таблица с сравнением языков по синтаксису представлена в таблице~@syntax-compare.

#таблица(table(
  columns: (0.85fr, 1fr, 1.6fr),
  table.header(
    c[Язык],
    c[Форма записи],
    c[Особенности синтаксиса],
  ),

  c[Forth],
  c[Постфиксная],
  // c[": NAME ... ;"],
  // c[комментарии "( ... )", "\" ..."; строки ".\" ...\""],
  c[Управляющие конструкции реализуются как слова времени компиляции.],

  c[Joy],
  c[Постфиксная],
  // c["name == ... ."],
  // c[цитаты/списки "[ ... ]"; множества "{ ... }"; строки "..." ],
  c[Цитаты используются как данные, управление через комбинаторы ("i", "ifte", "primrec/linrec/binrec").],

  c[Cat],
  c[Постфиксная],
  // c["define name ... ;" (глобально и единственно)],
  // c[цитаты/замыкания "[ ... ]"; комбинаторы "if", "while"],
  c[Синтаксис близок к Joy.],

  c[Factor],
  c[Постфиксная],
  // c[": name ( ...~-- ... ) ... ;"],
  // c[цитаты "[ ... ]"; нотация "stack effects" как часть определения],
  c[Обязательное указание эффектов над стеком при объявлении функций.],

  c[Wasm],
  c[S-выражения],
  // c[(func ...), (module ...), импорты/экспорты],
  // c[структурированные блоки (block/loop/if) выражаются через форму модуля/функции],
  c[Нетрадиционная форма записи синтаксических конструкций],
))[ Сравнение синтаксиса языков (сводная таблица) ] <syntax-compare>

В общем случае в рассмотренных языках прослеживается следующая закономерность. Для языков, которые используются непосредственно программистами для написания программ вручную, применяется характерный конкатенативный синтаксис, что соответствует изначально заложенным в языки данного множества концепциям минималистичности и простоты. Вероятно, некоторую роль в сохранении такой формы играет фактор историчности: исторически первый стековый язык (Forth) обладал конкатенативным синтаксисом.

В то же время синтаксис языков, которые являются целями трансляции, представлен более широким разнообразием. В частности Wasm использует S-выражения~-- тоже одна из достаточно распространных форм синтаксиса для функциональных языков. S-выражения также соответствуют концепции простоты (РБНФ синтаксиса таких языков имеет относительно малый размер).

Таким образом, отличительная черта синтаксиса стековых языков~--минималистичный дизайн, который упрощает как механизмы разбора программ за счет упрощенного парсера, так и работу программиста за счет меньшего объема требуемых знаний о синтаксисе и высокой степени читаемости (исходя из убеждения, что чем проще синтаксис, тем проще его читать).

== Сравнение подходов к типизации и оптимизации программ

Сравнение подходов к типизации приведено в таблице~@typing-analysis-compare.

#таблица(table(
  columns: (0.75fr, 1.0fr, 1.9fr),
  table.header(
    c[Язык],
    c[Тип типизации],
    c[Доступный анализ программ],
  ),

  c[Forth (1971)],
  c[Бестиповой],
  c[Корректность интерпретации содержимого стека обеспечивается соглашениями и выявляется на этапе исполнения.],

  c[Joy (2001)],
  c[Динамическая],
  c[Динамическая проверка типов при выполнении.],

  c[Factor (2003)],
  c[Динамическая],
  c[Модуль "stack-checker" выполняет роль статического анализатора: абстрактная интерпретация эффектов слов на абстрактном стеке и проверка согласованности ветвей.],

  c[Cat (2006)],
  c[Статическая],
  c[Вывод типов и верификация формы и размера стека, гарантии согласованности ветвлений и инвариантов циклов.],

  c[Wasm (2017)],
  c[Статическая],
  c[Однопроходная валидация модуля по типам и структурированному управлению, предотвращение underflow и несогласованности типов до исполнения.],
))[ Сравнение подходов к типизации ] <typing-analysis-compare>

Согласно таблице~@typing-analysis-compare в процессе развития стековые языки программирования постепенно улучшают свои возможности динамического и статического анализа. Вместе с уровнем анализа растет также уровень безопасности программ.

Основные техники оптимизации показаны в таблице~@opt-table.

#таблица(table(
  columns: (1.35fr, 2.65fr),
  table.header(
    text(size: 12pt)[Оптимизация],
    text(size: 12pt)[Описание],
  ),

  text(size: 12pt)[Нитевой код (Forth)],
  text(size: 12pt)[Представление программы как последовательности ссылок на слова; снижает размер кода и удешевляет интерпретацию.],

  text(size: 12pt)[Разворачивание слов времени компиляции (Forth)],
  text(size: 12pt)[Трнсляция управляющих конструкций в примитивные переходы и последовательности слов, уменьшая накладные расходы управления.],

  // text(size: 12pt)[Переписывание и специализация без побочных эффектов (Joy)],
  // text(size: 12pt)[Конкатенация цитат, перестановка инструкций с сохранением формы и размера стека с точки зрения внешнего наблюдателя.],

  text(size: 12pt)[Инлайнинг цитат и макро-расширение (Factor)],
  text(size: 12pt)[Снижение накладных расходов вызовов и диспетчеризации за счёт разворачивания и специализации на этапе компиляции.],

  // text(size: 12pt)[Stack caching (общая техника)],
  // text(size: 12pt)[Кэширование верхних элементов стека в регистрах, уменьшение обращений к памяти и обновлений указателя стека.],

  // text(size: 12pt)[Динамические суперинструкции (общая техника)],
  // text(size: 12pt)[Объединение частых последовательностей инструкций в одну “суперинструкцию” для уменьшения диспетчеризации.],

))[ Специфичные техники оптимизации для стековых языков ] <opt-table>

Оптимизации в стековых языках можно условно разделить на две группы: преобразования представления и диспетчеризации команд (ускоряют интерпретатор/виртуальную машину) и оптимизации, использующие результаты анализа семантики (стек-эффекты, типы, структура управления), что позволяет убирать лишние проверки и преобразовывать программу без нарушения корректности. Стековые языки изначально поддерживают техники первой группы вследствие своей структуры (например, нитевой код Forth). С развитием подходов к статическому анализу становятся доступны оптимизации из второй группы~-- Cat, Wasm активно применяют оптимизации, основанные на эквивалентных преобразованиях структуры программы, для увеличения скорости работы и снижении размера веса программы.

// Отдельный класс оптимизаций для стековых виртуальных машин~-- stack caching: хранение части виртуального стека (обычно верхних элементов) в регистрах реальной машины, чтобы сократить число загрузок/выгрузок и обновлений указателя стека. В работах М. А. Эрлтля предложены и подробно исследованы статический подход (компилятор отслеживает состояние кэша как автомат) и динамический подход (несколько версий интерпретатора для разных состояний кэша), а также показано, что stack caching хорошо сочетается с динамическими суперинструкциями, которые уменьшают долю времени на диспетчеризацию команд~@ertl-stack-caching@ertl-diss@ertl-gregg04. Эти техники применимы не к одному конкретному языку, а к широкому классу реализаций стековых интерпретаторов и виртуальных машин, в том числе к реализациям, близким по модели исполнения к Forth, Factor и другим стековым системам.

== Выводы

// Области применения рассмотренных языков определяются тем, на какие ограничения и требования изначально ориентирована их модель исполнения. Forth применяется во встраиваемых и ресурсно-ограниченных системах и в системах реального времени, где наиболее характерны малый размер среды, предсказуемость поведения и возможность низкоуровневого управления аппаратурой через минимальное ядро и расширяемый словарь слов. Joy имеет преимущественно академическое и экспериментальное применение. Cat также относится к исследовательским языкам и изучает возможности верификации. Factor занимает нишу языка общего назначения: для него наиболее характерны развитая стандартная библиотека, инструменты разработки и оптимизирующая компиляция, при этом сохранён конкатенативный стиль и используется статический контроль формы стека (stack-checker) как средство повышения надёжности и производительности. WebAssembly используется как переносимый низкоуровневый формат для безопасного исполнения недоверенного кода, для него наиболее характерна предсказуемая семантика и совместимость с различными исходными языками и рантаймами.

В пути развития стековых языков видна тенденция: изначально работающие на низких уровнях абстракций благодаря простоте рантайма (в сравнении с нестековыми языками), высокой переносимости и оптимизациям, доступным при меньшей стоимость за счет структуры программ и модели исполнения (например, нитевой код Forth), стековые языки обзаводятся формальной базой, которая позволяет точно описывать работу программ и проводить развитой статический анализ и трансформации кода, нацеленные на уменьшение объема потребляемой памяти и увеличения скорости работы.

Одной из вершин достижений стековых языков можно считать Wasm. Исходные цели проектирования предлагают во многом подходящие для использования стекового языка условия, на основе которых выросла система, сочетающая в себе сразу несколько изначально трудносовмещаемых преимуществ: высокая портируемость под разные платформы (в сравнении с регистровыми виртуальными машинами), но при этом большая производительность (например, в сравнении с традиционными движками ECMAScript) за счет низкоуровневых интерфейсов и оптимизаций и верифицируемость (и оттого частично безопасность исполнения). Wasm вбирает в себя теоретические и практические наработки в области стековых языков, решая с помощью них сложную задачу исполнения прикладного кода с учетом заданных требований.

В результате анализа можно сделать вывод, что современная ниша стековых языков~-- это быстрые виртуальные машины, запускаемые на широком спектре устройств. Это утверждение также подтверждается фактом, что спецификации самых распространенных виртуальных машин (JVM, .NET CLR, Wasm) используют стековую модель исполнения кода.

= Анализ средств вывода типов стековых языков программирования <заголовок-вывод-типов>

Использование стека данных в качестве единого хранилища порождает несколько возможных проблем типизации. Первая~-- проблема несовпадение типов, когда на вход некоторой команде с вершины стека поступают данные неправильного типа. Вторая~-- проблема исчерпания стека, когда команда при выполнении пытается взять данные с пустого стека. Такие ошибки приводят к аварийным завершениям программ и тем самым снижают их надежность. В то же время от подобных ошибок можно защититься, если в момент компиляции программы статически определять состояния стека во все будущие моменты времени исполнения и в случае нахождения ошибки блокировать компиляцию программы как небезопасной. Просчет возможных состояний стека для программы на стековом языке называется выводом ее типа.

В стековых языках тип для некоторого выражения определяется через эффект, который оказывает это выражение на конфигурацию стека данных при выполнении. В свою очередь конфигурация стека состоит из размера стека (сколько данных на нем лежит) и "формы" стека (данные каких типов на нем лежат). Задача вывода типов для стековых языков сводится к нахождению типа для всей программы~-- как программа поменяет конфигурацию стека при выполнении.

В общем случае выводом типов в языках программирования называется процесс, который позволяет установить неуказанный явно тип некоторого выражения в тексте программы по ограничениям окружения, где это выражение встречается. Разные языки обладают разными возможностями вывода в зависимости от размера области программы, которая используется для вывода типа. Некоторые языки допускают простые выводы, основанные на анализе только самого выражения, для которого выводится тип. Например, вывод типов в язык программирования Java ограничивается автоматическим определением типа переменной при ее объявлении по выражению, которое инициализирует данную переменную. Другие языки идут дальше и позволяют выводить типы по совокупности выражений и совокупности переменных, задействованных в этих выражениях в рамках функций. К примеру, Rust, который позволяет выводить тип переменной из контекста выражений, где эта переменная используется~-- так, если функция возвращает целое 32-битное число, то для гипотетической переменной, из которой делается возврат значения и которая может быть объявлена где угодно внутри такой функции, выводится соответственно тип целого 32-битного числа (то есть тип вывелся исходя из как минимум двух выражений, где переменная была задействована). Наконец существуют языки, вывод типов в которых осуществляется в рамках всей единицы трансляции~-- зачастую это языки с функциональной парадигмой. В таком случае типы для всей программы можно не указывать вовсе, так как все они будут выведены неявно при компиляции.

Для стековых языков алгоритмы вывода типов всей программы (последний случай, рассмотренный в предыдущем абзаце) актуальны, так как зачастую программисту затруднительно самому вычислить тип программы, что и порождает ошибки работы со стеком данных.

Для вывода типов в функциональных языках используется алгоритм Хиндли-Милнера. Вкратце алгоритм при запуске над несколькими выражениями сводится к двум шагам: сначала вычисляются ограничения, которые задаются формой выражений (например, одна переменная равна другой или переменная участвует в сложении, а потому должна быть складываемой), ограничения составляют систему уравнений, для которой вторым шагом ищется решение~-- такой набор типов, при подстановке которых, выражения останутся непротиворечивыми. Если набор найден, то типы выведены успешно, иначе~-- ошибка типизации.

Согласно идее, предложенной Кристофером Диггинсом, для стековых языков использование алгоритма Хиндли-Милнера также возможно, но с поправкой на row-полиморфизм. Row-полиморфизм~-- полиморфизм по размеру строки ("row"), состоянию стека данных. Все команды row-полиморфны и оперируют всем стеком сразу, который состоит из хвоста (типовой вектор, обозначается большими латинскими буквами) и единичных значений, лежащих на вершине стека (обозначаются маленькими латинскими буквами либо названиями типов, например "a" и "Bool"). Для цитат используется запись со скобками, показывающая отложенность описанных вычислений (пример, конфигурация стека, на котором лежит цитата "A (A -> B)").

Диггинс демонстрирует возможность статического вывода типов на примере своего экспериментального стекового языка Cat. Для встроенных команд приводятся типы, показанные на листинге~@cat-types.

#листинг(```
// Применение цитаты, которая приводит конфигурацию S к конфигурации R, к стеку S
apply   : (S (S -> R) -> R)
// Формирование цитаты, путем захвата значения с вершины стека
quote   : (S a -> S (R -> R a))
// Композиция двух цитат
compose : (S (B -> C) (A -> B) -> S (A -> C))
// Дублирование значения на вершине стека
dup     : (S a -> S a a)
// Удаление значения с вершины стека
pop     : (S a -> S)
// Перестановка двух значений с вершины стека
swap    : (S a b -> S b a)
// Примитив ветвления, выбирающий то или иное значения со стека в зависимости от значения Bool
cond    : (S Bool a a -> S a)
// Примитив циклических операций, выполняющий тело (цитата на вершине) пока верно условие (цитата под вершиной)
while   : ((S -> R Bool) (R -> S) S -> S)  
```)[ Типы встроенных команд Cat ] <cat-types>

Стоит обратить внимание на ограничения, которые ставят описанные в листинге~@cat-types типы. Для условного оператора "if" тип требует, чтобы обе ветви, принимая на вход одну и ту же конфигурацию стека, возвращали тоже одну и ту жу измененную конфигурацию стека (при этом конкретные значения на стеке, конечно, могут различаться). Для цикла "while" тип требует, чтобы после выполнения цикла конфигурация стека оставалась такой же, как и на момент начала цикла.

Алгоритм вывода типа заключается в последовательном "сцеплении" типов команд, образующих программу. В своем техническом отчете Диггинс приводит текстовое описание алгоритма и пример, в котором происходит вывод типа для программы "[ dup ] apply". В результате применения алгоритма получается следующая цепочка типов: "A a -> A a (A a -> A a a) -> A a a" (примечание, в отчете приводятся только начальная и конечная конфигурации стека, но аналогичным образом возможно построить и промежуточные конфигурации). Как видно, цитата и команда "apply" взаимно уничтожаются, из-за чего результирующий тип эквивалентен применению одиночной команды "dup" с точностью до промежуточных конфигураций.

Предложенный алгоритм имеет ограничение, заключающееся в невозможности вычислять рекурсивные типы. Из-за этого ограничения нельзя вычислить тип для программ, которые имеют рекурсивный поток управления. Также нельзя вычислить тип программ, предполагающих рекурсию за счет использования конструкции "dup apply" (объяснить это можно так: "apply" предполагает, что на стеке лежит некоторая цитата, которая переводит стек под собой из начального состояния в некоторое другое, но при этом "dup" говорит, что сама цитата также является частью этого начального состояния под собой). Такие ограничения можно снять, если расширить систему типов дополнительными конструкциями.

Таким образом для стековых языков возможно статически вывести форму и размер стека, и в случае наличия ошибок заранее их заметить. Признаком исчерпания стека служит наличие значений на вершине стека в начальной конфигурации программы~-- то есть программа ожидает, что на стеке до ее запуска уже что-то лежит, хотя это не так. Признак несовпадения типов выражается невозможностью найти решение системы уравнений в процессе очередной сцепки типов команд в программе.

= Анализ устройства байткода и модели исполнения WebAssembly <заголовок-wasm>

Байткод WebAssembly (или сокращенно Wasm) спроектирован как низкоуровневая переносимая платформа с околонативной производительностью вычислений. Поддерживается 2 формата описания программ Wasm: бинарное представление, понимаемое виртуальной машиной Wasm, и текстовое представление в синтаксисе S-выражений, удобное для чтения человеком. В зависимости от цели, одну и ту же программу возможно представить в обоих вариантах.

Единицей трансляции Wasm является модуль~-- описанный спецификацией Wasm файл, содержащий коды программ, наборы метаданных, информацию об импортах и экспортах и другие составляющие. Модуль является самостоятельной единицей, готовой к запуску на виртуальной машине. Для представления чисел используется формат little-endian (младшие разряды чисел записываются в младших адресах). При кодировании векторов (последовательностей значений) в начале блока данных записываются 4 байт значения длины векторов, а затем кодируемые данные. Строки кодируются как байтовые вектора utf-8.

Содержимое модуля состоит преамбулы (значение "\\0asm" и 4 байт номера версии) и основной части~-- набор секций. Каждая секция состоит из байта-идентификатора, 4 байт размера секции и полезной нагрузки в соответствии с идентификатором секции. Секции могут идти в произвольном порядке, но рекомендуется располагать их по мере увеличения идентификаторов.

Помимо модуля Wasm определяет также нескольких других сущностей, которые описываются в модуле:

- функции~-- блоки исполняемого кода;
- таблицы ссылок~-- механизм реализации указателей на функции, динамических вызовов;
- глобальные переменные и константы~-- набор типизированных изменяемых или неизменяемых значений фиксированного типа;
- линейная память~-- непрерывные последовательности байт;
- теги~-- механизм исключений.

Сущности каждого вида объединяются в индексные пространства, которые используются для ссылок между секциями. Если сущность из адресного пространства задается несколькими секциями (что верно для функций, таблиц и линейной памяти, у которых объявление и определение разделены на разные секции, подробнее в таблице~@wasm-секции), то нумерация в этих секциях идет параллельно (например, функция с индексом 1 задается объявлением с индексом 1 и определением с индексом 1). Внутри индексного пространства нумерация сквозная и начинается с 0. Сначала нумеруются импортированные сущности в порядке перечисления в секции импорта, затем аналогично в порядке перечисления в соответствующих секциях нумеруются внутренние сущности.

Описание каждой секции приведено в таблице~@wasm-секции.

#таблица(table(
  columns: (auto, auto, auto),
  table.header(c[ Ид. ], c[ Название ], c[ Описание ]),
  c[0], c[Custom section], c[Игнорируется виртуальной машиной, хранит произвольные данные. Может использоваться для различных целей, в том числе для отладки.],
  c[1], c[Type section], c[Объявления доступных для использования типов функций (типы параметров и типы результатов). Остальные секции ссылаются на данную при необходимости указать тип.],
  c[2], c[Import section], c[Объявления сущностей, которые импортируются в модуль для работы. Определения импортируемых сущностей предоставляют модули, которые их экспортируют.],
  c[3], c[Function section], c[Объявления типов для определенных в модуле функций, имеет параллельную с секцией Code нумерацию.],
  c[4], c[Table section], c[Объявления таблиц ссылок, имеет параллельную с секцией Element нумерацию.],
  c[5], c[Memory section], c[Объявления линейной памяти.],
  c[6], c[Global section], c[Объявления глобальных переменных.],
  c[7], c[Export section], c[Объявления публичных сущностей, которые могут быть импортированы другими модулями.],
  c[8], c[Start section], c[Объявление индекса функции, которую необходимо вызвать при инстанцировании модуля.],
  c[9], c[Element section], c[Объявления элементных сегментов~-- заполнения таблиц.],
  c[10], c[Code section], c[Объявления тел функций.],
  c[11], c[Data section], c[Объявление сегментов данных.],
  c[12], c[Data count section], c[Опциональное указание числа сегментов данных (Data section), которое ускоряет валидацию модуля.],
  c[13], c[Tag section], c[Объявления тегов для реализации механизма исключений.], 
))[ Описание секций модуля ] <wasm-секции>

Вызов функций возможен либо напрямую через указание индекса нужной функции либо косвенно через таблицу ссылок. Для операций над данными используется стек данных. Чтобы выполнить некую операцию, необходимо положить на стек требуемые данные, операция берет операнды со стека и кладет на стек результат выполнения. Функции действуют аналогично. Аналогично описанию в разделе~@заголовок-вывод-типов, тип функции описывает преобразование верхушки стека, которое осуществляет функция.

Спецификация Wasm использует идею "непрозрачных" указателей, которая выражается в том, что с точки зрения программы представление указателей не раскрывается, они выступают лишь значениями, которые ссылаются на что-то. Оперирование указателями осуществляется через отдельные команды. Указатели нельзя сохранять в линейную память~-- только в таблицы ссылок.

Wasm различает восстановимые и невосстановимые ошибки. Невосстановимые ошибки называются "trap" и приводят к аварийному завершению программы. Восстановимые ошибки реализованы как исключения. При возникновении исключения указывается его тег и машина раскручивает стек вызовов программы, пока не найдется обработчик соответствующего тега или стек вызовов будет раскручен полностью, и программа аварийно завершится.

Таким образом, спецификация WebAssembly предлагает низкоуровневую виртуальную машину. За счет низкого уровня и небольшого количества абстракций и ряда инженерных решений (таких как стековая архитектура, непрозрачные указатели) достигается во-первых малая удельная стоимость исполнения команд, что делает программы Wasm сопоставимы по скорости с нативными программами, а во-вторых снижается сложность реализаций виртуальной машины для различных аппаратных платформ (чем проще машина, тем проще ее реализовать) и вследствие этого увеличивается география устройств, для которых реализована виртуальная машина и возможно исполнение Wasm-программ. Эти преимущества делают Wasm подходящей платформой для запуска аппаратно-независимых программ на множества устройств, что активно используется в веб-разработке и облачных сервисах.

= Заключение

В результате выполнения преддипломной практики были проанализированы различные аспекты стековых языков программирования, алгоритм статического вывода типов для стековых языков, а также модель исполнения и структура WebAssembly. Полученные знания использованы при разработке программного обеспечения согласно теме "компилятор стекового языка программирования".

// Костыль, чтобы убрать отступы в списке использованных источников
#set bibliography(
  style: "bib.csl",
)
#show bibliography: it_bib => {
  set block(inset: 0pt)
  show block: it_block => {
    if it_block.body.func() != [].func() {
      it_block.body
    } else {
      par(it_block.body)
    }
  }
  it_bib
}
#bibliography("bibliography.yml")
