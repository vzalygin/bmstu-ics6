#import "version.typ": *

#show: гост732-2017

#metadata(true) <gost732-2017-feature-table-head-small-spacing>

#содержание()

= Введение

= Анализ средств вывода типов стековых языков программирования

Использование стека данных в качестве единого хранилища порождает несколько возможных проблем типизации. Первая -- проблема несовпадение типов, когда на вход некоторой команде с вершины стека поступают данные неправильного типа. Вторая -- проблема исчерпания стека, когда команда при выполнении пытается взять данные с пустого стека. Такие ошибки приводят к аварийным завершениям программ и тем самым снижают их надежность. В то же время от подобных ошибок можно защититься, если в момент компиляции программы статически определять состояния стека во все будущие моменты времени исполнения и в случае нахождения ошибки блокировать компиляцию программы как небезопасной. Просчет возможных состояний стека для программы на стековом языке называется выводом ее типа.

В стековых языках тип для некоторого выражения определяется через эффект, который оказывает это выражение на конфигурацию стека данных при выполнении. В свою очередь конфигурация стека состоит из размера стека (сколько данных на нем лежит) и "формы" стека (данные каких типов на нем лежат). Задача вывода типов для стековых языков сводится к нахождению типа для всей программы -- как программа поменяет конфигурацию стека при выполнении.

В общем случае выводом типов в языках программирования называется алгоритм, который позволяет установить неуказанный явно тип некоторого выражения в тексте программы по ограничениям окружения, где это выражение встречается. Разные языки обладают разными возможностями вывода в зависимости от размера области программы, которая используется для вывода типа. Некоторые языки допускают простые выводы, основанные на анализе только самого выражения, для которого выводится тип. Например, вывод типов в язык программирования Java ограничивается автоматическим определением типа переменной при ее объявлении по выражению, которое инициализирует данную переменную. Другие языки идут дальше и позволяют выводить типы по совокупности выражений и совокупности переменных, задействованных в этих выражениях в рамках функций. К примеру, Rust, который позволяет выводить тип переменной из контекста выражений, где эта переменная используется -- так, если функция возвращает целое 32-битное число, то для гипотетической переменной, из которой делается возврат значения и которая может быть объявлена где угодно внутри такой функции, выводится соответственно тип целого 32-битного числа (то есть тип вывелся исходя из как минимум двух выражений, где переменная была задействована). Наконец существуют языки, вывод типов в которых осуществляется в рамках всей единицы трансляции -- зачастую это языки с функциональной парадигмой. В таком случае типы для всей программы можно не указывать вовсе, так как все они будут выведены неявно при компиляции.

Для стековых языков алгоритмы вывода типов всей программы (последний случай, рассмотренный в предыдущем абзаце) актуальны, так как зачастую программисту затруднительно самому вычислить тип программы, что и порождает ошибки работы со стеком данных.

Для вывода типов в функциональных языках используется алгоритм Хиндли-Милнера. Вкратце алгоритм при запуске над несколькими выражениями сводится к двум шагам: сначала вычисляются ограничения, которые задаются формой выражений (например, одна переменная равна другой или переменная участвует в сложении, а потому должна быть складываемой), ограничения составляют систему уравнений, для которой вторым шагом ищется решение -- такой набор типов, при подстановке которых, выражения останутся непротиворечивыми. Если набор найден, то типы выведены успешно, иначе -- ошибка типизации.

Согласно идее, предложенной Кристофером Диггинсом, для стековых языков использование алгоритма Хиндли-Милнера также возможно, но с поправкой на row-полиморфизм. Row-полиморфизм -- полиморфизм по размеру строки ("row"), состоянию стека данных. Все команды row-полиморфны и оперируют всем стеком сразу, который состоит из хвоста (типовой вектор, обозначается большими латинскими буквами) и единичных значений, лежащих на вершине стека (обозначаются маленькими латинскими буквами либо названиями типов, например "a" и "Bool"). Для цитат используется запись со скобками, показывающая отложенность описанных вычислений (пример, конфигурация стека, на котором лежит цитата "A (A -> B)").

Диггинс демонстрирует возможность статического вывода типов на примере своего экспериментального стекового языка Cat. Для встроенных команд приводятся типы, показанные на листинге @cat-types.

#листинг(```
// Применение цитаты, которая приводит конфигурацию S к конфигурации R, к стеку S
apply   : (S (S -> R) -> R)
// Формирование цитаты, путем захвата значения с вершины стека
quote   : (S a -> S (R -> R a))
// Композиция двух цитат
compose : (S (B -> C) (A -> B) -> S (A -> C))
// Дублирование значения на вершине стека
dup     : (S a -> S a a)
// Удаление значения с вершины стека
pop     : (S a -> S)
// Перестановка двух значений с вершины стека
swap    : (S a b -> S b a)
// Примитив ветвления, выбирающий то или иное значения со стека в зависимости от значения Bool
cond    : (S Bool a a -> S a)
// Примитив циклических операций, выполняющий тело (цитата на вершине) пока верно условие (цитата под вершиной)
while   : ((S -> R Bool) (R -> S) S -> S)  
```)[ Типы встроенных команд Cat ] <cat-types>

Алгоритм вывода типа заключается в последовательном "сцеплении" типов команд, образующих программу. В своем техническом отчете Диггинс приводит текстовое описание алгоритма и пример, в котором происходит вывод типа для программы "[ dup ] apply". В результате применения алгоритма получается следующая цепочка типов: "A a -> A a (A a -> A a a) -> A a a" (примечание, в отчете приводятся только начальная и конечная конфигурации стека, но аналогичным образом возможно построить и промежуточные конфигурации). Как видно, цитата и команда "apply" взаимно уничтожаются, из-за чего результирующий тип эквивалентен применению одиночной команды "dup" с точностью до промежуточных конфигураций.

Предложенный алгоритм имеет ограничение, заключающееся в невозможности вычислять рекурсивные типы. Из-за этого ограничения нельзя вычислить тип для программ, которые имеют рекурсивный поток управления. Также нельзя вычислить тип программ, предполагающих рекурсию за счет использования конструкции "dup apply" (объяснить это можно так: "apply" предполагает, что на стеке лежит некоторая цитата, которая переводит стек под собой из начального состояния в некоторое другое, но при этом "dup" говорит, что сама цитата также является частью этого начального состояния под собой). Такие ограничения можно снять, если расширить систему типов дополнительными конструкциями.

Таким образом для стековых языков возможно статически вывести форму и размер стека, и в случае наличия ошибок заранее их заметить. Признаком исчерпания стека служит наличие значений на вершине стека в начальной конфигурации программы -- то есть программа ожидает, что на стеке до ее запуска уже что-то лежит, хотя это не так. Признак несовпадения типов выражается невозможностью найти решение системы уравнений в процессе очередной сцепки типов команд в программе.

= Анализ устройства байткода и модели исполнения WebAssembly

Байткод WebAssembly (или сокращенно Wasm) спроектирован как низкоуровневая переносимая платформа для околонативной производительности вычислений. Поддерживается 2 формата описания программ Wasm: бинарное представление, понимаемое виртуальной машиной Wasm, и текстовое представление в синтаксисе S-выражений, удобное для чтения человеком. В зависимости от цели, одну и ту же программу возможно представить в обоих вариантах.

Единицей трансляции Wasm является модуль -- описанный спецификацией Wasm файл, содержащий коды программ, наборы метаданных,информацию об импортах и экспортах и другие составляющие. Модуль является самостоятельной единицей, готовой к запуску на виртуальной машине.

// TODO про порядок следования байт в числах и других особенностях кодирования

Содержимое модуля состоит преамбулы, magic-значения "\\0asm", номера версии и последовательности секций. Каждая секция состоит из полей идентификатора от 0 до 255, размера секции и полезной нагрузки, определяемой номером секции. Секции могут идти в произвольном порядке, но рекомендуется располагать их по мере увеличения идентификаторов.

// TODO сущности wasm
Помимо модуля Wasm определяет также нескольких других сущностей:

- функции;
- таблицы ссылок, необходимые для ???;
- глобальные переменные и константы;
- линейная память;
- теги.

Сущности каждого вида объединяются в индексные пространства, которые используются для ссылок между секциями. Если сущность из адресного пространства задается несколькими секциями (что верно для функций, таблиц и линейной памяти, у которых объявление и определение разделены на разные секции), то нумерация в этих секциях идет параллельно. Внутри индексного пространства нумерация сквозная и начинается с 0. Сначала нумеруются импортированные сущности в порядке перечисления в секции импорта, затем аналогично в порядке перечисления в соответствующих секциях нумеруются внутренние сущности.

Описание каждой секции приведено в таблице @wasm-секции.

#let c(content) = {
  text(size: 12pt)[#content]
} 

#таблица(table(
  columns: (auto, auto, auto),
  table.header(c[ Ид. ], c[ Название ], c[ Описание ]),
  c[0], c[Custom section], c[Игнорируется виртуальной машиной, хранит произвольные данные. Может использоваться для различных целей, в том числе для отладки.],
  c[1], c[Type section], c[Объявления доступных для использования типов функций (типы параметров и типы результатов). Остальные секции ссылаются на данную при необходимости указать тип.],
  c[2], c[Import section], c[Объявления сущностей, которые импортируются в модуль для работы.],
  c[3], c[Function section], c[Объявления типов для определенных в модуле функций, имеет параллельную с секцией Code нумерацию.],
  c[4], c[Table section], c[Объявления таблиц ссылок, имеет параллельную с секцией Element нумерацию.],
  c[5], c[Memory section], c[Объявления линейной памяти.],
  c[6], c[Global section], c[Объявления глобальных переменных.],
  c[7], c[Export section], c[Объявления публичных сущностей, которые могут быть импортированы другими модулями.],
  c[8], c[Start section], c[Объявление индекса функции, которую необходимо вызвать при инстанцировании модуля.],
  c[9], c[Element section], c[Объявления элементных сегментов -- заполнения таблиц.],
  c[10], c[Code section], c[Объявления тел функций.],
  c[11], c[Data section], c[Объявление сегментов данных.],
  c[12], c[Data count section], c[Опциональное указание числа сегментов данных (Data section), которое ускоряет валидацию модуля.],
  c[13], c[Tag section], c[Объявления тегов для реализации механизма исключений.], 
))[ Описание секций модуля ] <wasm-секции>

// формат WAT и WASM
// модуль
// описание секций
// вызовы функций
// работа с памятью, в том числе непрозрачные указатели
// про механизм ошибок и восстановимые и невосстановимые ошибки

= Заключение

// Костыль, чтобы убрать отступы в списке использованных источников
#set bibliography(
  style: "bib.csl",
)
#show bibliography: it_bib => {
  set block(inset: 0pt)
  show block: it_block => {
    if it_block.body.func() != [].func() {
      it_block.body
    } else {
      par(it_block.body)
    }
  }
  it_bib
}
#bibliography("bibliography.yml")
