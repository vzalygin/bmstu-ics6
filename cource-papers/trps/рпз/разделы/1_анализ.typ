#import "@docs/gost732-2017:0.1.1": таблица, рис

= Анализ требований и уточнение спецификаций

== Анализ задания и выбор технологии, языка и среды разработки

В соответствии с требованиями технического задания необходимо разработать программу, которая позволит компилировать код на исходном языке в исполнямые файлы, собирать в объектные файлы и транслировать в ассемблерные листинги. Компилятор должен обеспечивать поддержку ряда синтаксических конструкций, представляющих исходный язык и перечисленных в техническом задании. Исполняемые файлы, объектные файлы, ассемлерные листинги, являющиеся результатом работы компилятора, должны соответствовать набору команд x86-64. Программное обеспечение должно работать под управлением ОС Linux и иметь интерфейс командной строки.

Исторически к программам-компиляторам предъявляются требования по скорости работы, нативности, наличию интерфейса командной строки. Иными словами, привычный компилятор -- скомпилированное нативное CLI-приложение без сборщика мусора. При разработке решения учитываются общие требования к программному обеспечению данной направленности.

Вышеперечисленные требования сужают диапазон подходящих языков программирования до нескольких штук: C, C++, Rust, Zig. В результате по совокупности факторов был выбран язык Rust. Компилятор данного языка обеспечивает автоматический контроль за состоянием памяти на этапе компиляции, сам язык обладает наиболее строгой системой типов (среди предложенных). Указанные особенности Rust позволяют писать безопасное программное обеспечение (TODO: рофл линк на новость про безопасные языки США) и недопустить ошибки при разработке программы. В таблице @сравнение-языков-программирования показаны результаты сравнения языков программирования.

Для разработки на данном языке принято использовать Visual Studio Code, поэтому она выбрана в качестве среды разработки.

#таблица(table(
  inset: 10pt,
  columns: (1fr, 1fr, 1fr, 1fr, 1.1fr),
  [], [ C ], [ C++ ], [ Zig ], [ Rust ],
  [ Работа с памятью ], [ Ручная ], [ Ручная ], [ Ручная ], [ Автоматическая ],
  [ Компиляция в нативный код], [ Да ], [ Да ], [ Да ], [ Да ],
  [ Зрелость и стабильность ], [ Да ], [ Да ], [ Нет ], [ Скорее да ],
  [ Современные методы разработки ], [ Нет ], [ Да ], [ Да ], [ Да ]
))[ Сравнение свойств языков программирования ] <сравнение-языков-программирования>

Поскольку процессы в рамках предметной области (создание исполняемых файлов, объектных файлов, ассемблерных листингов) можно описать как последовательность вызовов функций, постепенно преобразующих код от исходного языка до исполняемого файла, рационально использовать структурный подход. Структурный подход также является идиоматичным при разработке на Rust. 

== Разработка фунциональной диаграммы

В соответствии с техническим заданием программное решение должно обеспечивать создание различных выходных файлов.

Для разработки решения необходимо разложить процесс создания выходных файлов на этапы.

Процесс создания ассемблерного листинга можно разбить на 2 этапа:

- разбор кода программы;
- трансляция в языка ассемблера (компиляция).

В случае, если необходимо собрать объектный файл, то к 2 этапам создания ассемблерного листинга добавляется еще один этап -- "компоновка объектного файла".

В случае, если необходимо сделать исполняемый файл, то к 3 этапам сборки объектного файла добавляется еще один этап -- "компоновка исполняемого файла".

TODO: обновить диаграммы и вставить

== Разработка диаграммы вариантов использования

Поскольку техническое задание предполагает реализацию различные варианты использования программы, целесообразно показать их на диаграмме вариантов использования. Рисунок @диаграмма-вариантов-использования показывает возможности использования программного обеспечения.

#рис(image("../материалы/диаграмма вариантов использования.png", height: 50%), расположение: none)[ 
  Диаграмма вариантов использования
] <диаграмма-вариантов-использования>

== Разработка синтаксических диаграмм

