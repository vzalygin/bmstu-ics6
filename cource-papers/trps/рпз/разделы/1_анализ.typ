#import "@docs/gost732-2017:0.1.1": *

= Анализ требований и уточнение спецификаций

== Анализ вариантов использования
#h(0.5em)

Поскольку техническое задание предполагает реализацию различных вариантов использования программы, целесообразно показать их на диаграмме вариантов использования. Рисунок @диаграмма-вариантов-использования показывает возможности использования программного обеспечения.

#рис(image("../материалы/курсач_трпс-OK Диаграмма вариантов использования.drawio.png", height: 40%), расположение: none)[ 
  Диаграмма вариантов использования
] <диаграмма-вариантов-использования>

Отношения расширения определены из-за того, что расширяемый вариант использования является частью расширяющего варианта использования, но с дополнительными действиями. Так, создание объектного файла включает в себя создание ассемблерного листинга, который затем ассемблируется в объектный файл. Создание исполняемого файла включает в себя создание объектного файла, который затем компонуется с стандартной библиотекой в исполняемый файл. Количество дополнительных действий, которые выполняются при запуске программы, определяется при помощи выбранного режима работы. В зависимости от режима будет выполнен либо полный цикл операций над текстом программы, либо какая-то его часть.

На основе диаграммы вариантов использования можно составить ключевые варианты использования. В таблице @вариант-использования1 содержится информация о взаимодействии программиста с системой при генерации исполняемого файла с учетом ошибок, которые программист может допустить в программе.

#таблица(table(
  columns: (1fr, 1fr),
  [Действия пользователя], [Отклик системы],
  [ #set align(left)
1) Программист создает файл с программой, составляет команду вызова компилятора и делает вызов. \
3) Программист исправляет ошибки в файле с программой. \
5) Программист запускает исполняемый файл или передает его на дальнейшее исполнение.
  ], [ #set align(left)
2) Компилятор возвращает сообщение с синтаксической ошибкой. \
4) Компилятор выполняет генерацию и порождает исполняемый файл.
  ],
))[ Сценарий генерации исполняемого файла] <вариант-использования1>

Одним из основных сценариев является генерация объектных файлов, которые за счет интеграции через систему сборки, могут быть скомпонованы с другими объектными файлами. Таблица @вариант-использования2 демонстирует сценарий генерации объектного файла через использование системы сборки.

#таблица(table(
  columns: (1fr, 1fr),
  [Действия пользователя], [Отклик системы],
  [ #set align(left)
1) Программист создает файл кодом, включает файл в список системы сборки, вызывает систему сборки, которая дает команду компилятору. \
3) Программист вызывает стороннюю систему сборки, которая компонует полученный объектный файл с другими объектными файлами в исполняемый файл. \
4) Программист запускает исполняемый файл или передает его на дальнейшее исполнение.
  ], [ #set align(left)
2) Компилятор выполняет генерацию объектного файла в соответствии с переданными флагами.
  ],
))[ Сценарий генерации объектного файла] <вариант-использования2>

== Анализ задания и выбор технологии, языка и среды разработки <анал-задания>
#h(0.5em)

В соответствии с требованиями технического задания необходимо разработать программу, которая может выполнять трансляцию кода на исходном языке. Компилятор должен обеспечивать поддержку ряда синтаксических конструкций, представляющих исходный язык и перечисленных в техническом задании. Исполняемые файлы, объектные файлы, ассемлерные листинги, являющиеся результатом работы компилятора, должны соответствовать набору команд x86-64 @спецификация-ассемблера-x64. Программное обеспечение должно работать под управлением ОС Linux и иметь интерфейс командной строки.

Исторически к программам-компиляторам предъявляются требования по скорости работы, нативности, наличию интерфейса командной строки @unix. Иными словами, привычный компилятор -- скомпилированное нативное CLI-приложение без сборщика мусора. При разработке решения  также учитываются общие требования к программному обеспечению данной направленности, перечисленные раннее.

Вышеперечисленные требования сужают диапазон подходящих языков программирования до нескольких вариантов: C, C++, Rust, Zig. В результате по совокупности факторов был выбран язык Rust. Компилятор данного языка обеспечивает автоматический контроль за состоянием памяти без использования сбощика мусора, сам язык обладает наиболее строгой системой типов (среди предложенных) @документация-rust. Указанные особенности Rust позволяют писать безопасное решение/*(TODO: рофл линк на новость про безопасные языки США)*/ и недопускать ошибки в программном обеспечении. В таблице @сравнение-языков-программирования показаны результаты сравнения языков программирования.

Для разработки на данном языке принято использовать Visual Studio Code, поэтому она выбрана в качестве среды разработки.

#таблица(table(
  columns: (1fr, 1fr, 1fr, 1fr, 1.1fr),
  [], [ C ], [ C++ ], [ Zig ], [ Rust ],
  [ Работа с памятью ], [ Ручная ], [ Ручная ], [ Ручная ], [ Автоматическая ],
  [ Компиляция в нативный код], [ Да ], [ Да ], [ Да ], [ Да ],
  [ Зрелость и стабильность ], [ Да ], [ Да ], [ Нет ], [ Скорее да ],
  [ Современные методы разработки ], [ Нет ], [ Да ], [ Да ], [ Да ]
))[ Сравнение свойств языков программирования ] <сравнение-языков-программирования>

Поскольку процессы в рамках предметной области (создание исполняемых файлов, объектных файлов, ассемблерных листингов) удобно описывать как последовательность вызовов функций, поэтапно преобразующих код от исходного языка до исполняемого файла, рационально использовать структурный подход. Структурный подход также является идиоматичным при разработке на Rust.

Компилятор Rust автоматически контролирует состояние памяти, проверая корректность работы с памятью. Проверка осуществляется за счет концепций "владения" и "заимствования". При написании программы программист должен объяснить компилятору, как используется память в программе, а компилятор должен проверить, что такое использование безопасно. Преимуществом такого подхода по сравнению с другими автоматическими решениям является то, что все проверки осуществляются на этапе компиляции, что позволяет на этапе исполнения достичь производительность языков с ручной работой с памятью.

Под зрелостью и стабильностью подразумевается наличие стабильного канала выпуска новых версий программного обеспечения. Стабильным каналом принято называть канал, в рамках которого сохраняется обратная совместимость между версиями программного обеспечения, а также осуществляется долгосрочная поддержка версий.

Наконец критерий "современные методы разработки" учитывает поддержку языком принятых в профессиональном сообществе стандартов написания кода и программых продуктов. Так, например, язык С не поддерживает концепцию generic objects, в то время, как это делают все остальные указанные языки.

При создании программного обеспечения целесообразно проводить разработку нисходящим способом, как одним из рекомендуемых @технология-программирования. Версионирование программного обеспечения осуществляется при помощи инструмента git. Для проверки работоспособности используются автотесты, а в репозитории проекта настроен CI-процесс, который запускает автотесты с целью проверки изменений при попытке их фиксации.

Для создания интерфейса командной строки рационально использовать готовую библиотеку описания интерфейса -- Clap @документация-clap. Для разбора исходных кодов можно использовать комбинаторный подход и библиотеки, предоставляющие набор компонентов для построения генераторов комбинаторых парсеров. В данном случае используется библиотека Nom @документация-nom. С целью ускорения разработки рационально использовать готовые решения для ассемблирования и компоновки. Под целевую платформу (Linux x64) одними из самых распрастраненных являются ассемблер nasm и компоновщик ld, они используются в рамках данной разработки.

== Анализ процессов компиляции, ассемблирования, компоновки <анал-процессов>
#h(0.5em)

В соответствии с техническим заданием (приложение Б) программное решение должно обеспечивать создание различных выходных файлов.

Для разработки решения необходимо разложить процесс создания выходных файлов на этапы.

Процесс создания ассемблерного листинга можно разбить на 2 этапа:

- разбор кода программы,
- трансляция в языка ассемблера (компиляция).

В случае, если необходимо собрать объектный файл, то к 2 этапам создания ассемблерного листинга добавляется еще один этап -- "ассемблирование в объектный файл".

В случае, если необходимо сделать исполняемый файл, то к 3 этапам сборки объектного файла добавляется еще один этап -- "компоновка исполняемого файла".

На рисунке @функциональная-диаграмма-база представлена функциональная диаграмма процесса трансляции программы при помощи программного решения.

Рисунок @функциональная-диаграмма-трансляция уточняет блок A0, процесс трансляции исходного кода.

Рисунок @функциональная-диаграмма-сборка уточняет блок А3, процесс сборки.

#рис(image("../материалы/функциональная диаграмма 1.png", width: 80%), расположение: none)[ Функциональная диаграмма ] <функциональная-диаграмма-база>

#рис(image("../материалы/функциональная диаграмма 2.png", width: 100%), расположение: none)[ Функциональная диаграмма, уточняющая процесс трансляции ] <функциональная-диаграмма-трансляция>

#рис(image("../материалы/функциональная диаграмма 3.png", width: 100%), расположение: none)[ Функциональная диаграмма, уточняющая процесс сборки ] <функциональная-диаграмма-сборка>

Спецификации объектных файлов, исходного языка, языка ассемблера, механизмы, слияния

Спецификация исходного языка описывает синтаксис и семантику языка. Спецификация языка ассемблера описывает синтаксис и семантику языке ассемблера, используемого в целевой архитектуре Linux x64. Спецификация объектных файлов в рамках данного проекта описывает возможности работы с объектными файлами.

Ассемблирование программы на языке ассемблера, как было указано в подразделе @анал-задания, осуществляется при помощи программы nasm. Блок А4, который обозначает процесс ассемблирования, использует программу nasm (показан механизмом на диаграмме), так как согласно подразделу @анал-задания программа nasm выбрана в качестве ассемблера. Процесс компоновки использует программу ld, указанную как механизм, так как программа ld выбрана в качестве механизма осуществления компоновки объектных файлов.

Согласно диаграмме вариантов использования существует 3 варианта использования программы-компилятора. С целью передачи информации программе при вызове о требуемом варианте ее использования введено понятие режима работы, которое описывает, в рамках какого варианта использования программе необходимо работать.

При работе с программой в разных режимах используется унифицированный интерфейс обращения, который включает в себя 3 параметра: режим работы, входной файл, выходной файл. В связи с унификацией, тип выходного файла зависит от выбранного режима работы, на диаграммах это показано слиянием стрелок, идущих из разных блоков, и в результате объединяющихся в стрелку "выходной файл".
