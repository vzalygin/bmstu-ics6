#import "@docs/gost732-2017:0.1.1": *
#import "@docs/bmstu:0.1.1": *

#приложение(буква: "А")

#align(center)[
  #strong[
    #upper[
      РУКОВОДСТВО ПРОГРАММИСТА
    ]
  ]
  \ Листов 5
]

#страница(image("../материалы/титул_руководство_программиста.svg"))

#set heading(outlined: false)

#h(1.25cm) #нумерованный_заголовок(номер: 1)[ 
  Общие сведения о программном продукте
]

Настоящий документ был сформирован специально для программного продукта компилятора языка с синтаксисом на основе обратной польской записи (далее, исходный язык). Компилятор предоставляет возможности компиляции программ, написанных на исходном языке, в исполняемые файлы под набор команд x64 и операционную систему Linux.

= Требования к системе

Компьютер, на котором запускается компилятор должен работать под управлением операционной системой Linux и уметь установленные программы nasm и ld.

Компьютер, на котором запускаются скомпилированные компилятором исполняемые файлы должен работать под управлением операционной системы Linux и поддерживать набор команд x64.

= Описание установки и запуска

Для debian-like дистрибутивов ОС Linux достаточно выполнить следующее:

1. убедиться, что в системе установлены sh и curlж
2. открыть терминал;
3. выполнить команду curl -sSfL https://raw.githubusercontent.com/vzalygin/plc/refs/heads/master/install.sh | sh
4. дождать завершения установки и закрыть терминал.

Для дистрибутивов необходимо выполнить следующее:

1. установить сборщик пакетов cargo по официальной инструкции (ссылка на официальную инструкцию: https://doc.rust-lang.ru/book/ch01-01-installation.html);
2. склонировать репозиторий с компилятором (ссылка на репозиторий: https://github.com/vzalygin/plc);
3. выполнить команду cargo build \--refease в корневой папке репозитория
5. дождаться сборки компилятора;
4. переместить собранный исполяемый файл mv target/release/plc /usr/bin.

После установки программа станет доступна в терминале по названию plc (postfix language compiler).

= Инструкция по работе

Обращение к программе происходит через терминал с помощью команд, начинающихся с plc. После имени plc возможно указать несколько флагов. Если данный набор флагов недопустим, то компилятор выведет сообщение об этом. Компилятор поддерживает несколько флагов, регулирующих его режим работы:

- -h (длинный \--help), вызов информационного сообщения;
- -V (длинный \--version), вызов сообщения с версией компилятора;
- -c (длинный \--assemble-only), только ассемблирование в ассемблерный листинг;
- -S (длинный \--compile-only), только создание объектного файла, без компоновки;
- -o (длинный \--output), указание пути до выходного файла, путь необходимо написать после флага;

При отсутствии флагов компилятор при вызове собирает исполняемый файл по пути ./output.

= Описание исходного языка

Исходный язык имеет синтаксис на основе обратной польской записи, что означает, что в языке оператор идет после своих операндов. Исходный язык относится к стековым языкам, поскольку оперирует одним глобальным хранилищем -- стеком, который поддерживает 2 операции, положить значение и вытащить значение. Язык поддерживает операции над 32-битными целочисленными значениями со знаком, над бинарными значениями (подмножество целочисленных значений, состоящее из двух элементов -- 0 и 1), над списками операций. Список доступных операций с их описанием приведен ниже:

- "число", положить число на стек;
- ".", взять число со стека и подать его на stdout;
- "&", прочитать число из stdin и положить его на стек;
- "+", взять 2 числа со стека и сложить, результат положить на стек:
- "-", взять 2 числа со стека и вычесть, результат положить на стек, вычитаемым является число;
- "\*", взять 2 числа со стека и умножить, результат положить на стек;
- "\/", взять 2 числа со стека и разделить целочисленно, результат положить на стек, делителем является число;
- "dup", взять элемент со стека, сгенерировать такой же элемент и положить оба элемента на стек;
- "drop", взять эемент со стека и выбросить его;
- "take", взять число со стека и вытащить из стека на вершину стека элемент, находящийся на глубине, равной вытащенному числу;
- "[ операции ]", сформировать список операций и положить его на стек;
- "!", взять список со стека и положить операции внутри него на стек;
- "b", взять число и преобразовать его в бинарное значение по правилу, что если число равно 0, то бинарное значение тоже равно 0, иначе бинарное значение равно 1;
- "==", взять два числа со стека и сравнить их, положить бинарное значение, означающее верность их равенства;
- "!=", взять два числа со стека и сравнить их, положить бинарное значение, означающее верность их неравенства;
- ">", взять два числа и сравнить их, положить бинарное значение, означающее веронсть отношения "больше" между ними;
- ">=", взять два числа и сравнить их, положить бинарное значение, означающее веронсть отношения "больше или равно" между ними;
- "<", взять два числа и сравнить их, положить бинарное значение, означающее веронсть отношения "меньше" между ними;
- "<=", взять два числа и сравнить их, положить бинарное значение, означающее веронсть отношения "меньше или равно" между ними;
- "and", взять два элемента и выполнить поразрядное И между ними, результат положить на стек (если элементы -- бинарные значения, операция между ними соответствует логическому И);
- "or", взять два элемента и выполнить поразрядное ИЛИ между ними, результат положить на стек (если элементы -- бинарные значения, операция между ними соответствует логическому ИЛИ);
- "not", взять число со стека и выполнить поразрядное НЕ, результат положить на стек;
- "?", взять со стека бинарное значение и два других элемента, если бинарное значение означает верно, то положить на стек последний вытащенный элемент, иначе положить предпоследний вытащенный элемент;
- ":имя", взять элемент со стека и привязать к нему указанное имя;
- "имя", положить на стек элемент, привязанный к указанному имени.

Для всех операций, берущих со стека несколько операндов, верно, что первым операндом является последний вытащенный из стека элемент.

= Пример программы на исходном языке

Язык является полным по Тьюрингу, поэтому на нем можно реализовать любой вычислимый алгоритм. 

Листинг А содержит в себе пример программы на исходном языке, вычисляющей факториал:

#[ 
  #set par(first-line-indent: 0cm, justify: false) 
  Листинг А
  #set align(left)
  #set text(font: "Courier New", size: 12pt)
  #set par(leading: 0.65em)
  #box(
        stroke: black, 
        inset: 10pt, 
        width: 100%
  )[
```
[
    dup              # dup N for the next iterations
    [                # if current N greater than 1
        dup 1 -      # copy N and decrement for the next iteration
        fac!         # call the next iteration
        *            # after call multiply current N and the product of the next iterations
    ]
    [                # if current N is 1
                     # then do nothing
    ]
    [2 take 1 > ]!   # get current N and compare is that greater then 1
    ?!               # execute if and chosen branch
] :fac               # bind a list to a "fac" name

&                    # input N
fac!                 # put and apply the list
.                    # print the result
```
  ]
]
