#import "@docs/gost732-2017:0.1.1": рис, таблица, листинг

= Проектирование структуры и компонентов программного продукта

== Проектирование структуры приложения <структура>

Согласно подразделу @анал-задания расчетно-пояснительной записки в рамках разработки был выбран структурный подход. Для работы при таком подходе необходимо уточнить структурную схему программного решения. На рисунке @структурная-схема изображена структура проекта.

#рис(image("../материалы/структурная схема.png"))[ Структурная схема ] <структурная-схема>

Описание частей структурной схемы приведено ниже:

- программа-компилятор, главная часть программного решения;
- интерфейс, часть, содержащая подграммы, ответственные за взаимодействие с пользователем;
- библиотека компонентов трансляции, агрегирует компоненты, участвующие в процессе трансляции;
- компонент разбора текстов, включает в себя подпрограммы для разрбора тестов исходного языка;
- компонент компиляции, содержит подграммы, участвующие в процессе компиляции абстрактного синтаксического дерева в язык ассемблера целевого набора команд;
- компонент сборки, агрегирует подпрограммы, ответственные за сборку и компоновку.

== Проектирование интерфейса командной строки

При использовании нисходящего подхода, который был выбран в подразделе @анал-задания, необходимо начинать разработку от компонентов верхнего уровня, постепенно спускаясь вниз к компонентам нижних уровней. После уточнения структурной схемы в пункте @структура наиболее верним компонентом оказался компонент пользовательского интерфейса, в связи с чем с него начата разработка.

Согласно техническому заданию приложение должно иметь интерфейс командной строки. Для наглядности используется синтаксическая диаграмма грамматики интерфейса. Грамматика показа с использованием расширенной формы Бекуса-Наура. Форма изображена на рисунке @рбнф. Аксиомой грамматики является нетерминал "plc".

#рис(image(
  "../материалы/курсач_трпс-ОК РБНФ.drawio.png", width: 110%
))[ РБНФ интерфейса ] <рбнф>

Интерфейс командной строки соответствует принятым идиомам проектирования интерфейсов для консольных приложений. Интерфейс состоит из ключевого слова "plc", служащего именем приложения и началом команд для него, из набора флагов, определяющих поведение приложения, из имен файлов, которыми должна оперировать программа.

Флаги, определяющие поведение, деляется на 2 типа: опции трансляции (на диаграмме обозначены нетерминалом "run_options") и информацинные опции (нетерминал "info_options"). Перечисление поддерживаемых флагов и их семантика представлены в таблице @флаги.

#таблица(table(
  columns: (0.5fr, 0.6fr, 0.6fr, 1fr),
  [ Тип флага ], [ Краткая форма флага ], [ Длинная форма флага ], [ Назначение ],
  [ Информационный ], [-h], [\--help], [ Вывод сообщения  с информацией о приложении и доступных действиях ],
  [ Информаицонный ], [-V], [\--version], [ Вывод версии приложения ],
  [ Опция трансляции ], [-S], [\--compile-only], [ Выполнение только компиляции кода в ассемблерный листинг ],
  [ Опция трансляции ], [-c], [\--assemble-only], [ Создание только объектного файла],
  [ Опция трансляции ], [-o], [\--output], [ Указание пути до выходного файла ],
))[ Поддерживаемые флаги ] <флаги>

В случае, если никакой флаг не был выставлен, то используется режим работы с созданием исполняемого файла по пути ./output.

Наконец нетерминал "file" обозначает путь до файла. Программа принимает корректные пути операционной системы Linux.

== Разработка алгоритмов

В подразделе @анал-процессов описаны функциональные диаграммы процессов, в рамках которых используется решение. Для переноса процессов в программное обеспечение необходимо описать алгоритмы, соответствующие процессам. В качестве представления алгоритом целесообразно использовать схемы алгоритмов. На рисунке @схема-алго-1 представлен алгоритм для основной подпрограммы. В рамках основной подграммы происходит выбор режима, а также вызов агрегирующей подпрограммы "выполнить".

#рис(image("../материалы/курсач_трпс-1 Схемы алгоритмов.drawio.png", height: 90%))[ Алгоритм работы основной подпрограммы ] <схема-алго-1>

Схема алгоритма работы библиотечной подпрограммы "выполнить" представлена на рисунке @схема-алго-2. В зависимости от режима работы подграмма выполняет разное количество шагов для создания результирующего выходного файла. Для выполнения промежуточных шагов используются временные файлы. После проведения необходимых операций и получения выходного файла временные файлы удаляются.

#рис(image("../материалы/курсач_трпс-2 Схемы алгоритмов.drawio.png", height: 95%))[ Схема алгоритма подпрограммы "выполнить"] <схема-алго-2>

Поскольку язык обладает стандартной библиотекой (подробнее об этом изложено в подразделе @компилятор), существует подпрограмма подготовки к компоновке файла стандартной библиотеки. Алгоритм данной подпрограммы показан на рисунке @схема-алго-3. Алгоритм соотвествует аналогичному для кода из входного файла, но оперирует заранее заготовленными ассемлерными листингами для создания объектного файла.

#рис(image("../материалы/курсач_трпс-3 Схемы алгоритмов.drawio.png", height: 60%))[ Схема алгоритма подпрограммы подготовки стандартной библиотеки ] <схема-алго-3>

== Разработка синтаксиса грамматики исходного языка и парсера <парсер>

Выбранная библиотека для построения генераторов комбинаторных парсеров, Nom, позволяет реализовать разбор выражений методов рекурсивного спуска. Также по техническому заданию необходимо реализовать разбор ряда конструкций в синтаксисе обратной польской записи. В связи с данными ограничениями аксиома языка описывает подходящий под требования конкатенативный язык. Аксиома изображена на рисунке @аксиома. Определение аксиомы утверждает, что каждый "терм" окружен либо другими "термами", либо разделителями, либо началом и окончанием файла.

#рис(image(
  "../материалы/курсач_трпс-1 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма аксиомы исходного языка ] <аксиома>

Одним из самых главных правил в грамматике является правило "терм", обозначающее некоторую операцию. Рисунок @терм показывает синтаксическую диаграмму правила "терм". "Терм" означает синтаксическую единицу, команду на исходном языке. 

#рис(image(
  "../материалы/курсач_трпс-2 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма "терм" ] <терм>

Между термами могут располагаться разделители, в том числе и комментарии (комментарий располгается от своего начала и до конца строки). Разделителями являются проблемы, переводы строки, табы. Синтаксическая диаграмма правил "разделитель" и "комментарий" показана на рисунке @разделитель.

Остальные правила изображены на рисунках @число, @термы, @список. Данные правила задают непосредственно команды исходного языке. На рисунке @список представлена синтаксическая диаграмма списков -- важного элемента языка, который, являясь рекурсивным, позволяет языку удовлетворить полноте по Тьюрингу.

#рис(image(
  "../материалы/курсач_трпс-3 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы "разделитель", "комментарий" ] <разделитель>

#рис(image(
  "../материалы/курсач_трпс-4 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма "число" ] <число>

#рис(image(
  "../материалы/курсач_трпс-5 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы правил для некоторых термов ] <термы>

#рис(image(
  "../материалы/курсач_трпс-6 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы правил "список", "имя", "привязать к имени", "положить именнованное значение" ] <список>

Для создания парсера выбрана библиотека Nom, написанная в парадигме комбинаторых парсеров. Составление парсера при комбинаторном подходе подразумевает использование подпрограмм-генераторов парсеров, в аргументах которых указываются необходимые для создания парсера параметры, и которые в результате вызова возвращают готовый к работе парсер. Важным аспектом при работе с генераторами парсеров является их возможность "комбинировать парсеры": для создания возвращаемого парсера, они могут использовать уже созданные парсеры, поданные в качестве аргументов. Комбинаторные парсеры позволяют близко к диаграммам описывать правила грамматики. Листинг @аксиома-парсер демонстрирует подпрограмму, осуществляющую разбор аксиомы языка. Данная подпрограмма наглядно иллюстрирует принципы комбинаторного подхода.

#листинг(```
pub fn axiom<'s, E: ParseError<&'s str> + ContextError<&'s str>>(
    inp: &'s str,
) -> IResult<&'s str, Vec<Term>, E> {
    delimited(
        many0(separator),
        many0(term.and(many0(separator))).map(|term_pairs| {
            term_pairs
                .into_iter()
                .map(|term_pair| term_pair.0)
                .collect()
        }),
        many0(separator),
    )
    .parse(inp)
}
```)[ Подпрограмма разбора аксиомы языка ] <аксиома-парсер>

Описания некоторых частей, использованных при построении подпрограммы разрабора аксиомы, приведено ниже:

- delimeted, генератор, который позволяет окружить данный парсер парсерами перед и после, игнорируя их результаты работы;
- separator, парсер, соответствующий правилу "разделитель";
- many0, генератор, использующий поданный парсер 0 или больше раз пока это возможно;
- term, парсер, соответствующий правилу "терм".

Поскольку язык конкатенативнен, его абстрактное синтаксическое дерево (далее, АСТ) вырождено в список, элементами которого являются структура, описывающая некоторую операцию (результат разбора парсера term). Результатом разбора исходного кода является АСТ, которое после отработки парсера передается на следующий этап обработки.

== Разработка подпрограммы-компилятора <компилятор>

На основе АСТ, полученного после разбора исходного кода (процесс описан в подразделе @парсер), создается ассемблерный листинг программы. Чтобы выполнить данную задачу, необходимую каждой операции сопоставить заготовку (шаблон) на языке ассемблера, удовлетворяющую семантике операции. Именно при разработке таких заготовок решается задача адаптации стекового языка (предназначенного для стековой машины) под регистровую машину.

Решение задачи адаптации заключается в низкоуровневой эмуляции стековой машины. В частности эмуляция стека операндов представлена выделенной под стек памятью и указателями на вершину и основание стека. Применение списков операций реализуется за счет стека вызовов. Оставшиеся операции реализуются за счет инструкций, взаимодействующих со стеками операндов и вызовов.

Операции и соответствующие им шаблоны на языке ассемблера представлены в таблице @ассемблер-шаблоны.

#[
  #set par(justify: false)
  #таблица(table(
    columns: (0.3fr, 1fr),
    [ Операция ], [ Шаблон ],
    [ Положить число ], [ ```
i!(Sub, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Mov, indirect_register!(Ebx), OP_SIZE, Op::Literal(*number as i64))
    ``` ],
    [ Добавить ], [ ```
i!(Mov, reg!(Eax), indirect_register!(Ebx)),
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Add, indirect_register!(Ebx), reg!(Eax)),
    ``` ],
    [ Делить ], [ ```
i!(Mov, reg!(Edi), indirect_register!(Ebx)),
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Xor, reg!(Rdx), reg!(Rdx)),
i!(Mov, reg!(Rax), indirect_register!(Ebx)),
i!(Cltq),
i!(Cqto),
i!(Div, reg!(Edi)),
i!(Mov, indirect_register!(Ebx), reg!(Eax)),
    ``` ],
    [ Вывести ], [ ```
i!(Call, oplabel!(STD_PRINT_FN_LABEL))
    ``` ],
    [ Дублировать ], [ ```
i!(Mov, reg!(Eax), indirect_register!(Ebx)),
i!(Sub, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Mov, indirect_register!(Ebx), reg!(Eax)),
    ``` ],
    [ Удалить ], [ ```
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES))
    ``` ],
    [ Вытащить ], [ ```
i!(Xor, reg!(Rcx), reg!(Rcx)),
i!(Mov, reg!(Ecx), indirect_register!(Ebx)),
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Cmp, reg!(Ecx), opexpr!("dword 0")),
i!(Jz, opexpr!(no_exch_label)),
i!(label!(exch_cycle_label.as_str())),
i!(Mov, reg!(Eax), opexpr!(format!("[EBX+ECX*{OP_SIZE_BYTES}]"))),
i!(Mov, reg!(Esi), opexpr!(format!("[EBX+ECX*{OP_SIZE_BYTES}-{OP_SIZE_BYTES}]"))),
i!(Mov, opexpr!(format!("[EBX+ECX*{OP_SIZE_BYTES}]")), reg!(Esi),
i!(Mov, opexpr!(format!("[EBX+ECX*{OP_SIZE_BYTES}-{OP_SIZE_BYTES}]")), reg!(Eax)),
i!(Sub, reg!(Ecx), opexpr!("dword 1")),
i!(Jnz, oplabel!(exch_cycle_label)),
i!(label!(no_exch_label.as_str())),
    ``` ],
    [ Применить список ], [ ```
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Call, opexpr!(format!("[EBX-{OP_SIZE_BYTES}]"))),
    ``` ],
    [ Преобразовать в булево значение ], [ ```
i!(Cmp, indirect_register!(Ebx), opexpr!("dword 0")),
i!(Mov, reg!(Eax), Op::Literal(1)),
i!(Cmovz, reg!(Eax), opexpr!(format!("[{DWORD_ZERO_LABEL}]"))),
i!(Mov, indirect_register!(Ebx), reg!(Eax)),
    ``` ],
    [ Отрицание ], [ ```
i!(Xor, indirect_register!(Ebx), opexpr!("dword -1")),
i!(Mov, reg!(Eax), Op::Literal(1)),
i!(Cmp, indirect_register!(Ebx), opexpr!("dword 0")),
i!(Cmovz, reg!(Eax), opexpr!(format!("[{DWORD_ZERO_LABEL}]"))),
i!(Add, indirect_register!(Ebx), reg!(Eax)),
    ``` ],
    [ Привязать значение к имени ], [ ```
i!(label!(name), opexpr!(format!("resq 1")))
i!(Mov, reg!(Rax), indirect_register!(Ebx)),
i!(Add, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Mov, opexpr!(format!("[{name}]")), reg!(Rax)),
    ``` ],
    [ Положить именнованное значение ], [ ```
i!(Mov, reg!(Rax), opexpr!(format!("[{name}]"))),
i!(Sub, reg!(Ebx), Op::Literal(OP_SIZE_BYTES)),
i!(Mov, indirect_register!(Ebx), reg!(Rax)),
    ``` ],
  ))[ Некоторые операции и ассемблерные шаблоны ] <ассемблер-шаблоны> 
]

Шаблоны описаны с использованием dsl, разработанного для удобной генерации кода на языке ассемблера. Для создания инструкции используется макрос i, который принимает мнемонику инструкции, а затем аргументы. Описание возможных аргументов приведено ниже:

- reg, работа с регистом;
- indirect_register, значение в памяти по адресу из регистра;
- opexpr, сырая формула;
- op::label, подстановка символа;
- op::literal, подстановка литерала.

Для последующего развития предусмотрена стандартная библиотека. В текущей версии решения реализованы функции ввода/вывода, выхода приложения. Библиотека собирается аналогично исходному коду в объектный файл, а затем компонуется с объектным файлом с точкой входа программы. 

/* Распределение регистров 

== Разработка программы-сборщика <сборщик>
*/
