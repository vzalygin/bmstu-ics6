#import "@docs/gost732-2017:0.1.1": рис, таблица, листинг

= Проектирование структуры и компонентов программного продукта

== Проектирование структуры приложения <структура>

Согласно подразделу @анал-задания расчетно-пояснительной записки в рамках разработки был выбран структурный подход. Для работы при таком подходе необходимо уточнить структурную схему программного решения. На рисунке @структурная-схема изображена структура проекта.

#рис(image("../материалы/структурная схема.png"))[ Структурная схема ] <структурная-схема>

Описание частей структурной схемы приведено ниже:

- программа-компилятор, главная часть программного решения;
- интерфейс, часть, содержащая подграммы, ответственные за взаимодействие с пользователем;
- библиотека компонентов трансляции, агрегирует компоненты, участвующие в процессе трансляции;
- компонент разбора текстов, включает в себя подпрограммы для разрбора тестов исходного языка;
- компонент компиляции, содержит подграммы, участвующие в процессе компиляции абстрактного синтаксического дерева в язык ассемблера целевого набора команд;
- компонент сборки, агрегирует подпрограммы, ответственные за сборку и компоновку.

== Проектирование интерфейса командной строки

При использовании нисходящего подхода, который был выбран в подразделе @анал-задания, необходимо начинать разработку от компонентов верхнего уровня, постепенно спускаясь вниз к компонентам нижних уровней. После уточнения структурной схемы в пункте @структура наиболее верним компонентом оказался компонент пользовательского интерфейса, в связи с чем с него начата разработка.

Согласно техническому заданию приложение должно иметь интерфейс командной строки. Для наглядности используется синтаксическая диаграмма грамматики интерфейса. Грамматика показа с использованием расширенной формы Бекуса-Наура. Форма изображена на рисунке @рбнф. Аксиомой грамматики является нетерминал "plc".

#рис(image(
  "../материалы/курсач_трпс-ОК РБНФ.drawio.png", width: 110%
))[ РБНФ интерфейса ] <рбнф>

Интерфейс командной строки соответствует принятым идиомам проектирования интерфейсов для консольных приложений. Интерфейс состоит из ключевого слова "plc", служащего именем приложения и началом команд для него, из набора флагов, определяющих поведение приложения, из имен файлов, которыми должна оперировать программа.

Флаги, определяющие поведение, деляется на 2 типа: опции трансляции (на диаграмме обозначены нетерминалом "run_options") и информацинные опции (нетерминал "info_options"). Перечисление поддерживаемых флагов и их семантика представлены в таблице @флаги.

#таблица(table(
  columns: (0.5fr, 0.6fr, 0.6fr, 1fr),
  [ Тип флага ], [ Краткая форма флага ], [ Длинная форма флага ], [ Назначение ],
  [ Информационный ], [-h], [\--help], [ Вывод сообщения  с информацией о приложении и доступных действиях ],
  [ Информаицонный ], [-V], [\--version], [ Вывод версии приложения ],
  [ Опция трансляции ], [-S], [\--compile-only], [ Выполнение только компиляции кода в ассемблерный листинг ],
  [ Опция трансляции ], [-c], [\--assemble-only], [ Создание только объектного файла],
  [ Опция трансляции ], [-o], [\--output], [ Указание пути до выходного файла ],
))[ Поддерживаемые флаги ] <флаги>

В случае, если никакой флаг не был выставлен, то используется режим работы с созданием исполняемого файла по пути ./output.

Наконец нетерминал "file" обозначает путь до файла. Программа принимает корректные пути операционной системы Linux.

== Разработка алгоритмов

В подразделе @анал-процессов описаны функциональные диаграммы процессов, в рамках которых используется решение. Для переноса процессов в программное обеспечение необходимо описать алгоритмы, соответствующие процессам. В качестве представления алгоритом целесообразно использовать схемы алгоритмов. На рисунке @схема-алго-1 представлен алгоритм для основной подпрограммы. В рамках основной подграммы происходит выбор режима, а также вызов агрегирующей подпрограммы "выполнить".

#рис(image("../материалы/курсач_трпс-1 Схемы алгоритмов.drawio.png", height: 90%))[ Алгоритм работы основной подпрограммы ] <схема-алго-1>

Схема алгоритма работы библиотечной подпрограммы "выполнить" представлена на рисунке @схема-алго-2. В зависимости от режима работы подграмма выполняет разное количество шагов для создания результирующего выходного файла. Для выполнения промежуточных шагов используются временные файлы. После проведения необходимых операций и получения выходного файла временные файлы удаляются.

#рис(image("../материалы/курсач_трпс-2 Схемы алгоритмов.drawio.png", height: 95%))[ Схема алгоритма подпрограммы "выполнить"] <схема-алго-2>

Поскольку язык обладает стандартной библиотекой (подробнее об этом изложено в подразделе @разраб-компилятор), существует подпрограмма подготовки к компоновке файла стандартной библиотеки. Алгоритм данной подпрограммы показан на рисунке @схема-алго-3. Алгоритм соотвествует аналогичному для кода из входного файла, но оперирует заранее заготовленными ассемлерными листингами для создания объектного файла.

#рис(image("../материалы/курсач_трпс-3 Схемы алгоритмов.drawio.png", height: 60%))[ Схема алгоритма подпрограммы подготовки стандартной библиотеки ] <схема-алго-3>.

== Разработка синтаксиса исходного языка

Выбранная библиотека для построения генераторов комбинаторных парсеров, Nom, позволяет реализовать разбор выражений методов рекурсивного спуска. Также по техническому заданию необходимо реализовать разбор ряда конструкций в синтаксисе обратной польской записи. В связи с данными ограничениями аксиома языка описывает подходящий под требования конкатенативный язык. Аксиома изображена на рисунке @аксиома. Определение аксиомы утверждает, что каждый "терм" окружен либо другими "термами", либо разделителями, либо началом и окончанием файла.

#рис(image(
  "../материалы/курсач_трпс-1 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма аксиомы исходного языка ] <аксиома>

Одним из самых главных правил в грамматике является правило "терм", обозначающее некоторую операцию. Рисунок @терм показывает синтаксическую диаграмму правила "терм". "Терм" означает синтаксическую единицу, команду на исходном языке. 

#рис(image(
  "../материалы/курсач_трпс-2 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма "терм" ] <терм>

Между термами могут располагаться разделители, в том числе и комментарии (комментарий располгается от своего начала и до конца строки). Разделителями являются проблемы, переводы строки, табы. Синтаксическая диаграмма правил "разделитель" и "комментарий" показана на рисунке @разделитель.

Остальные правила изображены на рисунках @число, @термы, @список. Данные правила задают непосредственно команды исходного языке. На рисунке @список представлена синтаксическая диаграмма списков -- важного элемента языка, который, являясь рекурсивным, позволяет языку удовлетворить полноте по Тьюрингу.

#рис(image(
  "../материалы/курсач_трпс-3 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы "разделитель", "комментарий" ] <разделитель>

#рис(image(
  "../материалы/курсач_трпс-4 Синтаксическая диаграмма.drawio.png"
))[ Синтаксическая диаграмма "число" ] <число>

#рис(image(
  "../материалы/курсач_трпс-5 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы правил для некоторых термов ] <термы>

#рис(image(
  "../материалы/курсач_трпс-6 Синтаксическая диаграмма.drawio.png"
))[ Синтаксические диаграммы правил "список", "имя", "привязать к имени", "положить именнованное значение" ] <список>

== Разработка подпрограммы-компилятора <разраб-компилятор>
