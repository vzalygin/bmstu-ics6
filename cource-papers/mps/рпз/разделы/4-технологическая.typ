#import "../version.typ": *

= Технологическая часть

== Выбор инструментов и средств разработки

При разработке программной части устройства на языке C используется компилятор avr-gcc (версия тулчейна 3.7.0_1796) и стандартной библиотеки avr-libc, которые обеспечивают доступ к регистрам периферии и специализированным функциям работы с программной памятью и внешним ОЗУ микроконтроллера ATmega128A. Работа с исходным кодом выполняется в среде Visual Studio Code как наиболее дружелюбной к всем остальным средствам разработки благодаря многочисленным расширениям и интеграциям.

Сборка проекта выполняется утилитой make, которая последовательно запускает компиляцию модулей, линковку и генерацию прошивки в формате Intel HEX (содержимое Makefile представлено в приложении А). В Makefile выделяются отдельные цели для компиляции, записи прошивки и очистки промежуточных файлов. Для программирования микроконтроллера используется утилита avrdude, вызываемая из make с заранее подготовленным набором параметров интерфейса программирования и сигнатуры целевого МК.

== Программирование МК

На рисунке @structure показана структурная схема программной части устройства.

#рис(image("../материалы/mps-Структурная схема.drawio.png", width: 90%))[ Структурная схема ] <structure>

Логика программы делится на два крупных блока. Первый блок составляют модули оригинального синтезатора речи SAM: файлы "sam.c", "debug_sam.c", "reciter.c", "ReciterTabs.c", "render.c", "RenderTabs.c", "SamTabs.c". Данные файлы реализуют алгоритмы преобразования текста в фонемы, последующую обработку фонем и формирование дискретизированного звукового сигнала по таблицам частот и амплитуд.  Эти файлы по сути представляют собой перенесённое ядро синтезатора и в минимальной степени зависят от аппаратной платформы (с поправкой на необходимые манипуляции при портированнии на микропроцессорную платформу, описанные в дальнейших разделах).

Второй блок — модули «обвязки», которые выполняют функцию окружения для синтезатора и связывают его с аппаратными средствами микроконтроллера. В "main.c" находится основной цикл работы устройства и обработка команд пользователя. Модуль "uart.c" настраивает интерфейс USART1 микроконтроллера и перенаправляет стандартные потоки ввода-вывода stdin и stdout на последовательный порт. Модуль "buffer.c" реализует кольцевой буфер для асинхронного приёма данных по UART, а "player.c" отвечает за воспроизведение сгенерированного звукового буфера через ШИМ-выход. В файлах "memmanagment.h" и "memmanagment.c" сосредоточены вспомогательные средства работы с программной и внешней памятью, а модуль "translator.c" содержит алгоритмы транслитерации русского текста в английский.

== Общая модель исполнения

Рисунок @main-loop иллюстрирует основной цикл работы устройства: после аппаратного сброса выполняется инициализация основных подсистем устройства: настраивается контроллер внешней памяти, интерфейс UART, модуль проигрывателя и глобальные структуры синтезатора речи. Затем разрешаются прерывания, и управление передаётся в основной бесконечный цикл.

#рис(image("../материалы/mps-Схема алгоритмов главная.drawio.png"))[ Основной цикл работы ] <main-loop>

Основной цикл организован как обработчик входного потока слов. Текст от ведущего устройства по интерфейсу UART помещается в асинхронный кольцевой буфер, откуда цикл по мере готовности извлекает очередное слово. По первому символу определяется тип слова. Если оно начинается с "-", слово интерпретируется как команда изменения параметров синтеза: команды настраивают высоту тона, скорость и тембр звучания, возвращают справочную информацию. Неизвестные команды игнорируются с формированием диагностического сообщения. Если слово не имеет префикса "-", оно рассматривается как элемент произносимого текста и передаётся в функцию генерации речи.

Функция «Сказать слово», алгоритм которой изображён на рисунке @say, связывает между собой модули трансляции, синтеза и проигрывателя. На вход она получает слово или короткую фразу, выделенную из входного потока. Сначала выполняется нормализация текста: символы переводятся в верхний регистр и передаются модулю трансляции, который заменяет буквы кириллицы соответствующими латинскими последовательностями. Результирующая строка полностью соответствует требованиям синтезатора S.A.M. и передаётся в его ядро.

#рис(image("../материалы/mps-Схема алгоритмов Сказать.drawio.png", width: 55%))[ Схема алгоритма основной функции генерации речи ] <say>

В ходе работы синтезатора во внешней памяти формируется буфер дискретизированного звукового сигнала. После завершения синтеза функция проверяет состояние проигрывателя, при необходимости ожидает его освобождения и затем запускает асинхронное воспроизведение, передавая структуру с описанием буфера и callback-функцию освобождения памяти. После старта проигрывателя управление немедленно возвращается в основной цикл. Таким образом, общая модель исполнения строится по принципу: основной цикл управляет приёмом и разбором текста, а ресурсоёмкий синтез речи и вывод звука выполняются в специализированных модулях и обработчиках прерываний.

== Портирование S.A.M. под МК ATMega128A

Алгоритм синтеза SAM, схематично показанный на рисунке @sam, в портированной версии сохраняет исходную структуру. Сначала выполняется инициализация внутренних буферов синтезатора. Затем вызывается первый проход парсера фонем, который преобразует входной текст в последовательность фонем с базовыми характеристиками. Второй проход уточняет фонемы, добавляет вставки и подготавливает таблицы длительностей. Далее накладываются эффекты ударения и дыхания, после чего модуль рендера формирует выборки звукового сигнала, комбинируя несколько гармоник с различными амплитудами и формами волн.  Полученный буфер передаётся в проигрыватель.

Программа SAM изначально создавалась как настольное приложение и ориентируется на особенности персональных ПК: прямой доступ к оперативной памяти и сравнительно большой объём ОЗУ.  При переносе на ATmega128A возникает несколько ограничений: объём внутренней SRAM составляет всего 4 Кбайт, отсутствуют стандартные средства файлового ввода-вывода.  Эти особенности требуют переработки модели использования памяти.

В процессе портирования часть работы связана с устранением зависимостей от POSIX-совместимой среды. Функции вывода в файл заменяются на формирование буфера в оперативной памяти, а интерфейс командной строки — на набор функций, вызываемых из основного цикла микроконтроллера. Все обращения к динамической памяти и глобальным массивам адаптируются к разметке внешнего ОЗУ.

#рис(image("../материалы/mps-Схема алгоритмов SAM.drawio.png"))[ Схема алгоритма синтеза речи S.A.M. ] <sam>

=== Устранение ошибок сборки

Исходный код S.A.M. организован в несколько файлов, но многие переменные и функции предполагаются глобальными и не имеют явных прототипов. Для инкрементальной сборки с разделением на объектные файла код должен удовлетворять более строгим требованиям, поэтому на первом этапе портирования возникают многочисленные предупреждения и ошибки линковки. Для их устранения модули синтезатора разделяются на заголовочные и исходные файлы: в заголовках объявляются внешние функции и глобальные массивы с указанием принадлежности к определенной секции памяти, а единственное определение каждой сущности остаётся в одном .c-файле.

Глобальные таблицы фонем и параметров синтеза, к которым обращаются несколько модулей, объявляются в заголовках с ключевым словом extern, а в одном исходнике получают фактическое определение. Вспомогательные функции, используемые только внутри одного файла, помечаются как static, что предотвращает конфликт имён на этапе линковки и позволяет оптимизатору выполнять их развёртку. Такой пересмотр структуры проекта делает код более модульным и облегчает последующую отладку.

=== Работа с памятью программы

Весь код (макросы и одна вспомогательная функция) для удобства вынесены в отдельный заголовочный файл memmanagment.h, который затем подключается к остальным файлам проекта и обеспечивает поддержку работы с памятью данных. Содержимое memmanagment.h показано в листинге @memmanagment.h.

#листинг(```
#ifndef MEMMANAGMENT_H
#define MEMMANAGMENT_H

#include <avr/pgmspace.h>
#include <stdio.h>
#include <string.h>

#include "uart.h"

#define DATAMEM __attribute__((section(".data")))
#define NOINITMEM __attribute__((section(".noinit")))

#define printf(...) _PRINTF_IMPL(__VA_ARGS__)(__VA_ARGS__)
#define _PRINTF_IMPL(...)                                                      \
    _GET_MACRO(__VA_ARGS__, _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1,    \
               _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1, \
               _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_0)
#define _GET_MACRO(_fmt, _1, _2, _3, _4, _5, _6, _7, _8, _9, NAME, ...) NAME
#define _PRINTF_IMPL_0(fmt)                    \
    do {                                       \
        static const char MSG[] PROGMEM = fmt; \
        printf(copy_pgm_str(MSG));             \
    } while (0)
#define _PRINTF_IMPL_1(fmt, ...)                \
    do {                                        \
        static const char MSG[] PROGMEM = fmt;  \
        printf(copy_pgm_str(MSG), __VA_ARGS__); \
    } while (0)

extern char COPY_PGM_BUFFER[256] NOINITMEM;
const char* copy_pgm_str(const char* pgm_str);

#endif
```)[ Заголовочный файл memmanagment.h ] <memmanagment.h>

Макросы DATAMEM и NOINITMEM служат для явного указания секции размещения глобальных данных. Атрибут DATAMEM принудительно помещает переменную в стандартную инициализируемую секцию .data, которая загружается во внутреннюю SRAM при старте программы. Атрибут NOINITMEM размещает объект в секции .noinit, которая не очищается и не инициализируется кодом старта, так как сдвинута в область внешней памяти (конфигурация внешней памяти осуществляется уже после инициализации переменных).

Особое внимание уделяется переопределению функции "printf". Проблем заключается в необходимости перемещения всех строковых литералов (по большой части используемых в функции "printf") в флеш-память для освобождения памяти данных. Макрос "printf(...)" разворачивается препроцессором в последовательность макросов "\_PRINTF_IMPL" и "\_GET_MACRO", которые по числу аргументов выбирают один из двух вариантов реализации: с параметрами форматирования или без них. В обоих случаях строка формата объявляется как static const с атрибутом "PROGMEM", то есть сохраняется во флеш-памяти микроконтроллера и не занимает оперативное ОЗУ. Только во время непосредственного использования той или иной строки функция "copy_pgm_str" копирует строку формата из программной памяти во временный буфер "COPY_PGM_BUFFER", размещённый в секции ".noinit" во внешнем ОЗУ, и возвращает указатель на этот буфер. Благодаря этому стандартная функция "printf" из libc, ожидающая строку в адресном пространстве данных, может использоваться без модификации (что значительно снижает количество изменений в исходном коде SAM), а постоянные строки не расходуют ценный объём внутренней SRAM.

Реализация функции "copy_pgm_str" приведена в файле "memmanagment.c". Она использует функцию "strcpy_P" из заголовка "avr/pgmspace.h" для побайтного копирования строки из программной памяти в буфер "COPY_PGM_BUFFER" и возвращает указатель на него. Размер буфера выбран равным 256 байтам, что достаточно для диагностических и сервисных сообщений, используемых в проекте.

Благодаря указанным выше макросам можно гибко и явно определять структуру памяти. На рисунке @разметка-данных показано адресное пространство программы, подписаны различные секции программы и переменные линкера, которые отвечают за разметку.  

#рис(image("../материалы/mps-Структура памяти.drawio.png"))[ Разметка адресного пространства данных ] <разметка-данных>

Адресное пространство данных микроконтроллера ATmega128A делится на регистровую область, область регистров ввода-вывода и оперативную память. В нижней части пространства расположены регистры общего назначения и регистры периферии, далее следует внутренняя SRAM объёмом 4 Кбайт.  На рисунке эта область объединена в секцию DATA, где размещаются инициализируемые глобальные переменные, и в область стека STACK, растущего навстречу данным. Начиная с адреса 0x1100 доступна внешняя SRAM вплоть до конца адресного пространства. В этой области последовательно располагаются секция ".noinit" (8 кБайт) и динамическая куча HEAP (52 кБайт), используемая реализацией "malloc" для аллокации памяти под звуковой буфер.

Помимо разметки данных по секциям, для непосредственного назначения диапазонов адресов для секций данных необходимо передать несколько аргументов линкеру через переменные сборочного файла. Фрагмент файла с аргументами представлен в листинге @Makefile.

#листинг(```
LDFLAGS += -Wl,--defsym,__DATA_REGION_LENGTH__=0xffa0,--section-start=.noinit=0x801100,--defsym=__heap_start=0x803100,--defsym=__heap_end=0x80ffff
```)[ Выдержка из файла Makefile с флагами линкера ] <Makefile>

Переменная линкера "\_\_DATA_REGION_LENGTH\_\_" задаёт суммарную длину доступной области данных. В проекте для неё выбирается значение 0xffa0, что соответствует использованию всего диапазона от начала внутренней SRAM до конца внешней памяти, за вычетом служебной области. Параметр "\-\-section-start=.noinit=0x801100" указывает начальный адрес секции ".noinit" в расширенной области данных; фактический физический адрес соответствует 0x1100. Символы "\_\_heap_start" и "\_\_heap_end" определяют границы кучи, из которой выделяется память под выходные звуковые буферы.

== Модуль трансляции

Модуль трансляции необходим для перевода русских букв в английские транскрипции, так как алгоритмы синтеза работают только с английским языком и ожидают на входе текст в латинском алфавите. Заголовочный файл транслятора показан в листинге @translator.h.

Функция translate принимает указатель на выходной буфер, исходную строку и максимально допустимый размер результата (для корректной обработки ошибки переполнения). На вход подаётся уже приведённый к верхнему регистру текст. В процессе работы функция последовательно просматривает символы исходной строки, для каждого символа определяет, относится ли он к русскому алфавиту, и в зависимости от результата либо копирует символ напрямую, либо заменяет его на одну или несколько латинских букв согласно таблице транслитерации. Результат всегда завершается нулевым байтом, а запись не выходит за пределы указанного размера буфера.

#листинг(```
#ifndef TRANSLATOR_H
#define TRANSLATOR_H

void translate(char* dst, char* src, int dstsize);

#endif
```)[ Заголовочный файл translator.h ] <translator.h>

Алгоритм модуля трансляции представлен на рисунке @транслятор. Для каждого символа входного слова проверяется, является ли он русской буквой. Если это не так, символ без изменений добавляется в выходную строку. Если символ относится к кириллице, по таблице соответствий выбирается его транскрипция, после чего в выходную строку поочерёдно добавляются все символы этой транскрипции.

#рис(image("../материалы/mps-Схема алгоритмов Транслятор.drawio.png", width: 49%))[ Схема алгоритмов модуля трансляции ] <транслятор>

Модуль трансляции используется в функции «Сказать слово» перед вызовом синтезатора. В результате S.A.M. получает на вход строку, содержащую лишь латинские буквы, а особенности произношения русских слов моделируются с помощью заранее подобранных комбинаций английских букв.

== Достижение максимальной утилизации вычислительного ядра

Так как синтез речи является тяжёлой задачей, встаёт вопрос о грамотном использовании ограниченных ресурсов. Для увеличения полезного процента во времени утилизации вычислительного ядра активно применяются асинхронные алгоритмы, реализованные при помощи прерываний. Таким образом удаётся минимизировать время простаивания ядра в циклах ожидания, а освободившиеся ресурсы направить на вычислительно сложные этапы работы синтезатора. Рисунок @исп-проц иллюстрирует, как используется процессорное время.

#рис(image("../материалы/mps-Временная диаграмма использования процессорного времени.drawio.png"))[ Использование процессорного времени ] <исп-проц>

На временной диаграмме можно выделить несколько характерных фаз. В начале работы ядро кратковременно занято инициализацией устройства: настройкой внешней памяти, интерфейса UART, таймеров. Затем, после ожидания ввода слова для озвучивания, следует продолжительный интервал, в течение которого выполняется синтез речи; в это время основное ядро полностью загружено арифметическими вычислениями и обработкой таблиц фонем, звуков. Параллельно с этим приходящие по UART символы обрабатываются в прерывании и попадают в кольцевой буфер: таким образом входящие слова принимаются микроконтроллеров в любой момент времени, а не только когда микроконтроллер свободен.

После завершения синтеза запускается проигрыватель звукового файла. С этого момента основное ядро почти не участвует в выводе звука: обновление значения регистра сравнения ШИМ происходит в прерывании таймера, причём обработчик прерывания выполняется очень быстро и занимает лишь небольшие фрагменты времени между остальными задачами. Параллельно с проигрыванием текущего слова в случае готовности буфера начинается обработка следующего слова с прерываниями на обновления ШИМ. Временные интервалы ожидания освобождения проигрывателя и получения нового слова сведены к минимуму, так как вместо активного опроса периферии используются прерывания и программные флаги состояния. Такое распределение нагрузки позволяет максимально использовать процессорное время для тяжёлых вычислений синтеза речи, а операции ввода-вывода выполняются фрагментарно и не мешают синтезу.

=== Модуль асинхронного буфера входного потока

Принято решение реализовать получение входных данных при помощи специального входного буфера, который позволяет не терять данные, если они приходят уже во время активной вычислительной работы, а также снижает долю времени ожидания процессора. Данные в буфер попадают асинхронно из обработчика прерывания по приёму UART, а при готовности микроконтроллера взять в работу следующее слово считываются из буфера и передаются в обработку. Заголовочный файл в листинге @buffer.h показывает интерфейс буфера.

Структура buffer_t описывает кольцевой буфер фиксированного размера BUFFER_SIZE. Поле buf хранит указатель на область памяти, выделенную динамически при вызове make_buffer. Поля begin и end содержат индексы начала и конца данных в буфере и изменяются по модулю BUFFER_SIZE, что образует кольцевую структуру. Функция make_buffer выделяет память под массив символов, инициализирует индексы нулём и возвращает готовую структуру.

Функция buffer_is_empty вычисляет разность индексов с учётом циклического переполнения и возвращает признак пустоты буфера. Запись символа выполняется функцией buffer_write: символ помещается в позицию end, после чего индекс сдвигается вперёд по модулю BUFFER_SIZE. Функция buffer_read реализует блокирующее чтение: если в буфере нет символа для выдачи, выполняется ожидание, затем символ берётся из позиции begin, а индекс начала данных увеличивается. Объявление аргумента как volatile buffer_t\* гарантирует, что компилятор не оптимизирует обращения к полям структуры, поскольку они могут изменяться как в основном коде, так и в обработчике прерывания.

#листинг(```
#ifndef BUFFER_H
#define BUFFER_H

#define BUFFER_SIZE 256

typedef struct buffer_t {
    char* buf;
    int begin;
    int end;
} buffer_t;

buffer_t make_buffer();

int buffer_is_empty(volatile buffer_t* buffer);

void buffer_write(volatile buffer_t* buffer, char ch);

char buffer_read(volatile buffer_t* buffer);

#endif
```)[ Заголовочный файл buffer.h ] <buffer.h>

Логическая модель работы буфера показана на рисунке @схема-буфер. При чтении сначала проверяется, пуст ли буфер; если данных нет, алгоритм остаётся в состоянии ожидания до появления новых символов. При записи, согласно схеме, производится проверка наличия свободного места, затем в случае наличия свободного места -- запись в буфер и инкрементация поля смещения. 

#рис(image("../материалы/mps-Схема алгоритмов Буфер.drawio.png"))[ Схема алгоритмов буфера входного потока ] <схема-буфер>

=== Модуль асинхронного проигрывателя звукового файла

Асинхронный проигрыватель, интерфейс которого представлен в листинге @player.h, снимает задачу тяжёлого вывода и, совместно с асинхронным входным буфером, позволяет процессору проводить минимальное количество времени в состоянии ожидания.

Структура player_data_t описывает звуковой файл в памяти и содержит указатель на буфер выборок и его размер в байтах. Тип callback_func_t задаёт прототип функции обратного вызова, которая вызывается после завершения воспроизведения (функция нужна, так как запуск плеера не блокирует поток исполнения, при этом возможно должна выполняться какая-то работа после окончания проигрывания); в контексте устройства -- в callback-функции выполняется освобождение памяти из-под использованного звукового буфера. Функция init_player готовит периферию к работе проигрывателя: настраивает вывод OC0 в режим быстрый ШИМ, задаёт параметры таймера 1 и включает прерывание по совпадению с регистром OCR1A.

Функция make_player_data формирует структуру player_data_t из указателя и размера, упрощая передачу данных между модулями. Основная функция play является неблокирующей, принимает структуру с описанием буфера и указатель на callback. Внутри модуля происходят сохранение этих параметров во внутренние статические переменные, установка флага блокировки проигрывателя и сброс счётчика позиции, после чего запускается таймер. С этого момента воспроизведение происходит полностью в обработчике прерывания.

#листинг(```
#ifndef PLAYER_H
#define PLAYER_H

typedef struct player_data_t {
    char* buffer;
    unsigned int size;
} player_data_t;

typedef void (*callback_func_t)(volatile player_data_t* data);

void init_player();

player_data_t make_player_data(char* buffer, unsigned int size);

void play(player_data_t data, callback_func_t callback);

int is_player_blocked();

void wait_player();

#endif
```)[ Заголовочный файл player.h ] <player.h>

Функция is_player_blocked возвращает текущее состояние флага блокировки и используется для проверки готовности проигрывателя к приёму нового буфера. Функция wait_player реализует простое ожидание окончания воспроизведения, пока флаг блокировки не сброшен; она вызывается, чтобы гарантировать, что предыдущая фраза полностью прозвучала перед запуском следующей.

Внутренняя логика проигрывателя иллюстрируется на рисунке @схема-проигрыватель. Во время воспроизведения таймер генерирует прерывания с частотой, соответствующей частоте дискретизации звукового сигнала (22050 Гц). В обработчике прерывания очередной байт звукового буфера записывается в регистр OCR0, что приводит к изменению коэффициента заполнения ШИМ и, после фильтрации, к формированию аналогового звука на выходе. Затем увеличивается смещение в буфере; когда оно достигает размера звукового файла, таймер и ШИМ выключаются, флаг блокировки сбрасывается и вызывается callback-функция, освобождающая ресурсы.

Такая организация позволяет основному коду не заниматься непосредственной выдачей выборок: процессор лишь изредка выполняет короткий обработчик прерывания и остаётся свободен для синтеза следующего фрагмента речи или обработки команд, что в совокупности обеспечивает высокую утилизацию вычислительного ядра при ограниченных ресурсах микроконтроллера.

#рис(image("../материалы/mps-Схема алгоритмов Проигрыватель.drawio.png"))[ Схема алгоритмов проигрывателя ] <схема-проигрыватель>

Таким образом реализуется программная часть устройства.
