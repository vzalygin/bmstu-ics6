#import "../version.typ": *

= Технологическая часть

== Выбор инструментов и средств разработки

// Тут про симуляцию в proteus, vscode, make, avrdude

== Программирование МК

На рисунке @structure показана структурная схема программной части устройства.

#рис(image("../материалы/mps-Структурная схема.drawio.png"))[ Структурная схема ] <structure>

Для сборки проекта используется система сборки Make, скрипты сборки (Makefile) указаны в приложении А.

== Общая модель исполнения

#рис(image("../материалы/mps-Схема алгоритмов главная.drawio.png"))[ Основной цикл работы ] <main-loop>

#рис(image("../материалы/mps-Схема алгоритмов Сказать.drawio.png"))[ Схема алгоритма основной функции генерации речи ] <say>

== Портирование S.A.M. под МК ATMega128A

#рис(image("../материалы/mps-Схема алгоритмов SAM.drawio.png"))[ Схема алгоритма синтеза речи S.A.M. ] <sam>

// обзорно про возникающие в процессе портирования проблемы

=== Устранение ошибок сборки

// Разделение заголовочных файлов и сорсов, extern, static

=== Работа с памятью программы

Весь код (макросы и одна вспомогательная функция) для удобства вынесены в отдельный заголовочный файл memmanagment.h, который затем подключается к остальным файлам проекта и обеспечивает поддержку работы с памятью данных. Содержимое memmanagment.h показано в листинге @memmanagment.h.

#листинг(```
#ifndef MEMMANAGMENT_H
#define MEMMANAGMENT_H

#include <avr/pgmspace.h>
#include <stdio.h>
#include <string.h>

#include "uart.h"

#define DATAMEM __attribute__((section(".data")))
#define NOINITMEM __attribute__((section(".noinit")))

#define printf(...) _PRINTF_IMPL(__VA_ARGS__)(__VA_ARGS__)
#define _PRINTF_IMPL(...)                                                      \
    _GET_MACRO(__VA_ARGS__, _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1,    \
               _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_1, \
               _PRINTF_IMPL_1, _PRINTF_IMPL_1, _PRINTF_IMPL_0)
#define _GET_MACRO(_fmt, _1, _2, _3, _4, _5, _6, _7, _8, _9, NAME, ...) NAME
#define _PRINTF_IMPL_0(fmt)                    \
    do {                                       \
        static const char MSG[] PROGMEM = fmt; \
        printf(copy_pgm_str(MSG));             \
    } while (0)
#define _PRINTF_IMPL_1(fmt, ...)                \
    do {                                        \
        static const char MSG[] PROGMEM = fmt;  \
        printf(copy_pgm_str(MSG), __VA_ARGS__); \
    } while (0)

extern char COPY_PGM_BUFFER[256] NOINITMEM;
const char* copy_pgm_str(const char* pgm_str);

#endif
```)[ Заголовочный файл memmanagment.h ] <memmanagment.h>

// TODO Тут необходимо описать определенные в файле макросы и функции

Благодаря указанным выше макросам можно гибко и явно определять структуру памяти. На рисунке @разметка-данных показано адресное пространство программы, подписаны различные секции программы и переменные линкера, которые отвечают за разметку.  

#рис(image("../материалы/mps-Структура памяти.drawio.png"))[ Разметка адресного пространства данных ] <разметка-данных>

// TODO описание рисунка структуры памяти

Помимо разметки данных по секциям, для непосредтственного назначения диапазонов адресов для секций данных необходимо передать несколько аргументов линкеру через переменных сборочного файла. Фрагмент файла с аргументами предсталвен в листинге @Makefile.

#листинг(```
LDFLAGS += -Wl,--defsym,__DATA_REGION_LENGTH__=0xffa0,--section-start=.noinit=0x801100,--defsym=__heap_start=0x803100,--defsym=__heap_end=0x80ffff
```)[ Выдержка из файла Makefile с флагами линкера ] <Makefile>

// TODO описание переменных

== Модуль трансляции

Модуль трансляции неоходим для перевода русских букв в английские транскрицпии так как алгоритмы синтеза работают только с английским языком. Заголовочный файл транслятора показан в листинге @translator.h.

#листинг(```
#ifndef TRANSLATOR_H
#define TRANSLATOR_H

void translate(char* dst, char* src, int dstsize);

#endif
```)[ Заголовочный файл translator.h ] <translator.h>

// TODO Описание функций из заголовочного файла.

// TODO описание алгоритмов модуля трансляции и его использования

#рис(image("../материалы/mps-Схема алгоритмов Транслятор.drawio.png"))[ Схема алгоритмов модуля трансляции ] <транслятор>

== Достижение максимальной утилизации вычислительного ядра

Так как синтез речи является тяжелой задачей, встает вопрос о грамотном использовании ограниченных ресурсов. Для увеличения полезного процента в времени утилизации вычислительного ядра активно применяются асинхронные алгоритмы, реализованные при помощи прерываний. Таким образом удается достичь минимизации времени простаивания ядра в циклах ожидания, а освободившиеся ресурсы направить на тяжелые вычислительные задачи синтеза речи. Рисунок @исп-проц иллюстрирует, как используется процессорное время.

#рис(image("../материалы/mps-Временная диаграмма использования процессорного времени.drawio.png"))[ Использование процессорного времени ] <исп-проц>

// TODO описание использования процессорного времени (IO операции вынесены в )

=== Модуль асинхронного буфера входного потока

Принято решение реализовать получение входных данных при помощи специального входного буфера, который позволил не терять данные, если они приходят уже во активной вычислительной работы, а также снизить долю времени ожидания процессора (данные в буфер попадают асинхронно, а затем в необходимые момент читаются из буфера и берутся в работу). Заголовочный файл в листинге @buffer.h показывает интерфейс буфера. При помощи асинхронного буфера закрывается задача тяжелого ввода.

#листинг(```
#ifndef BUFFER_H
#define BUFFER_H

#define BUFFER_SIZE 256

typedef struct buffer_t {
    char* buf;
    int begin;
    int end;
} buffer_t;

buffer_t make_buffer();

int buffer_is_empty(volatile buffer_t* buffer);

void buffer_write(volatile buffer_t* buffer, char ch);

char buffer_read(volatile buffer_t* buffer);

#endif
```)[ Заголовочный файл buffer.h ] <buffer.h>

// TODO описание структуры буфера и функций

// Описание принципа работы при помощи схемы алгоритмов 

#рис(image("../материалы/mps-Схема алгоритмов Буфер.drawio.png"))[ Схема алгоритмов буфера входного потока ] <схема-буфер>

=== Модуль асинхронного проигрывателя звукового файла

Асинхронный проигрыватель, интерфейс которого представлен в листинге @player.h, снимает задачу тяжелого вывода, чем совместо с асинхронным входным буфером, позволяет процессору проводить минимальное количество времени в состоянии ожидания.

#листинг(```
#ifndef PLAYER_H
#define PLAYER_H

typedef struct player_data_t {
    char* buffer;
    unsigned int size;
} player_data_t;

typedef void (*callback_func_t)(volatile player_data_t* data);

void init_player();

player_data_t make_player_data(char* buffer, unsigned int size);

void play(player_data_t data, callback_func_t callback);

int is_player_blocked();

void wait_player();

#endif
```)[ Заголовочный файл player.h ] <player.h>

// TODO описание структур и функций

// Описание принципа работы при помощи схемы алгоритмов буфера

#рис(image("../материалы/mps-Схема алгоритмов Проигрыватель.drawio.png"))[ Схема алгоритмов проигрывателя ] <схема-проигрыватель>
